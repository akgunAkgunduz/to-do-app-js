{"version":3,"sources":["classes/store.js","classes/todoList.js","../src/purify.js","../src/tags.js","../src/attrs.js","../src/utils.js","../src/regexp.js","utils/helpers.js","templates/todoItem.js","classes/View.js","../node_modules/muuri/dist/muuri.js","classes/controller.js","app.js"],"names":["Store","JSON","parse","localStorage","getItem","todos","setItem","stringify","TodoList","items","name","completed","item","id","Date","now","push","console","table","i","length","splice","isCompleted","newName","newIndices","reorderedTodos","map","index","setItems","freeze","Object","x","html","svg","svgFilters","mathMl","text","xml","hasOwnProperty","setPrototypeOf","apply","Reflect","addToSet","set","array","l","element","lcElement","toLowerCase","isFrozen","clone","object","newObject","property","fun","thisValue","args","seal","MUSTACHE_EXPR","ERB_EXPR","DATA_ATTR","ARIA_ATTR","IS_ALLOWED_URI","IS_SCRIPT_OR_DATA","ATTR_WHITESPACE","arraySlice","Array","prototype","slice","getGlobal","window","_createTrustedTypesPolicy","trustedTypes","document","createPolicy","suffix","currentScript","hasAttribute","getAttribute","policyName","error","warn","createDOMPurify","DOMPurify","root","version","VERSION","removed","nodeType","isSupported","originalDocument","useDOMParser","removeTitle","DocumentFragment","HTMLTemplateElement","Node","NodeFilter","NamedNodeMap","MozNamedAttrMap","Text","Comment","DOMParser","TrustedTypes","template","createElement","content","ownerDocument","trustedTypesPolicy","emptyHTML","createHTML","implementation","createNodeIterator","getElementsByTagName","createDocumentFragment","importNode","hooks","createHTMLDocument","documentMode","EXPRESSIONS","ALLOWED_TAGS","DEFAULT_ALLOWED_TAGS","TAGS","ALLOWED_ATTR","DEFAULT_ALLOWED_ATTR","ATTRS","FORBID_TAGS","FORBID_ATTR","ALLOW_ARIA_ATTR","ALLOW_DATA_ATTR","ALLOW_UNKNOWN_PROTOCOLS","SAFE_FOR_JQUERY","SAFE_FOR_TEMPLATES","WHOLE_DOCUMENT","SET_CONFIG","FORCE_BODY","RETURN_DOM","RETURN_DOM_FRAGMENT","RETURN_DOM_IMPORT","SANITIZE_DOM","KEEP_CONTENT","IN_PLACE","USE_PROFILES","FORBID_CONTENTS","DATA_URI_TAGS","URI_SAFE_ATTRIBUTES","DEFAULT_URI_SAFE_ATTRIBUTES","CONFIG","formElement","_parseConfig","cfg","ADD_URI_SAFE_ATTR","ALLOWED_URI_REGEXP","ADD_TAGS","ADD_ATTR","_forceRemove","node","parentNode","removeChild","outerHTML","_removeAttribute","getAttributeNode","removeAttribute","_initDocument","dirty","doc","leadingWhitespace","matches","match","parseFromString","documentElement","body","firstElementChild","insertBefore","createTextNode","childNodes","call","querySelector","innerHTML","_createIterator","SHOW_ELEMENT","SHOW_COMMENT","SHOW_TEXT","FILTER_ACCEPT","_isNode","obj","nodeName","_executeHook","entryPoint","currentNode","data","forEach","_sanitizeElements","elm","_isClobbered","textContent","attributes","setAttribute","tagName","insertAdjacentHTML","htmlToInsert","test","cloneNode","replace","_isValidAttribute","lcTag","lcName","value","indexOf","_sanitizeAttributes","attr","idAttr","hookEvent","namespaceURI","trim","attrName","attrValue","keepAttr","setAttributeNS","pop","_sanitizeShadowDOM","fragment","shadowNode","shadowIterator","nextNode","sanitize","importedNode","oldNode","returnNode","toString","TypeError","toStaticHTML","appendChild","firstChild","nodeIterator","serializedHTML","setConfig","clearConfig","isValidAttribute","tag","addHook","hookFunction","removeHook","removeHooks","removeAllHooks","select","selector","string","createTodoItemContent","View","grid","list","input","handlers","itemDiv","itemContentDiv","classList","add","dataset","updateItemStyling","addEventListenersForTodoItem","removeEventListenersFromTodoItem","remove","removeElements","getItems","getElement","toggle","todoContent","deleteButton","editInput","selectItemElements","addEventListener","handleToggleClick","handleTodoContentDoubleClick","handleDeleteButtonClick","handleEditInputBlur","handleEditInputKeyup","removeEventListener","store","todoList","Muuri","dragEnabled","dragStartPredicate","handle","view","Controller","bind","provideItemHandlers","todo","addItemToGrid","updateItemIndices","e","key","target","sanitizedName","addItem","indices","getGrid","reorderItems","listItem","closest","parseInt","toggleItemStatus","focus","removeItem","removeItemFromGrid","sanitizedNewName","updateItemName","blur","handleInputKeydown","on","handleGridDragReleaseEnd","controller","initTodoList","setUpEventListeners"],"mappings":"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EAAA,EAAA,UAAA,IAAA,SAAA,EAAA,GAAA,iBAAA,SAAA,oBAAA,OAAA,OAAA,QAAA,IAAA,mBAAA,GAAA,EAAA,IAAA,EAAA,GAAA,EAAA,UAAA,IAAA,CAAA,KAAA,WAAA,aC/qCA,IAAMwB,EACJC,OAAOD,QACP,SAASE,GACAA,OAAAA,GAGEC,EAAOH,EAAO,CACzB,IACA,OACA,UACA,UACA,OACA,UACA,QACA,QACA,IACA,MACA,MACA,MACA,QACA,aACA,OACA,KACA,SACA,SACA,UACA,SACA,OACA,OACA,MACA,WACA,UACA,OACA,WACA,KACA,YACA,MACA,UACA,MACA,MACA,MACA,KACA,KACA,UACA,KACA,WACA,aACA,SACA,OACA,SACA,OACA,KACA,KACA,KACA,KACA,KACA,KACA,OACA,SACA,SACA,KACA,OACA,IACA,MACA,QACA,MACA,MACA,QACA,SACA,KACA,OACA,MACA,OACA,UACA,OACA,WACA,QACA,MACA,OACA,KACA,WACA,SACA,SACA,IACA,MACA,WACA,IACA,KACA,KACA,OACA,IACA,OACA,UACA,SACA,SACA,QACA,SACA,SACA,OACA,SACA,SACA,QACA,MACA,UACA,MACA,QACA,QACA,KACA,WACA,WACA,QACA,KACA,QACA,OACA,KACA,QACA,KACA,IACA,KACA,MACA,QACA,QAIWI,EAAMJ,EAAO,CACxB,MACA,IACA,WACA,cACA,eACA,eACA,gBACA,mBACA,QACA,SACA,SACA,WACA,OACA,OACA,UACA,SACA,OACA,IACA,QACA,WACA,QACA,QACA,OACA,iBACA,SACA,OACA,WACA,QACA,OACA,UACA,UACA,WACA,iBACA,OACA,OACA,QACA,SACA,SACA,OACA,WACA,QACA,OACA,QACA,QACA,OACA,UAGWK,EAAaL,EAAO,CAC/B,UACA,gBACA,sBACA,cACA,mBACA,oBACA,oBACA,iBACA,UACA,UACA,UACA,UACA,UACA,iBACA,UACA,cACA,eACA,WACA,eACA,qBACA,cACA,SACA,iBAGWM,EAASN,EAAO,CAC3B,OACA,WACA,SACA,UACA,QACA,SACA,KACA,aACA,gBACA,KACA,KACA,QACA,UACA,WACA,QACA,OACA,KACA,SACA,QACA,SACA,OACA,OACA,UACA,SACA,MACA,QACA,MACA,SACA,eAGWO,EAAOP,EAAO,CAAC,UCxOtBA,EACJC,OAAOD,QACP,SAASE,GACAA,OAAAA,GAGEC,EAAOH,EAAO,CACzB,SACA,SACA,QACA,MACA,eACA,aACA,UACA,SACA,cACA,cACA,UACA,OACA,QACA,QACA,QACA,OACA,UACA,WACA,SACA,cACA,WACA,UACA,MACA,WACA,WACA,UACA,OACA,MACA,UACA,SACA,SACA,OACA,OACA,WACA,KACA,YACA,QACA,QACA,OACA,OACA,OACA,MACA,MACA,YACA,QACA,SACA,MACA,WACA,OACA,UACA,aACA,SACA,OACA,UACA,UACA,cACA,SACA,UACA,UACA,aACA,WACA,MACA,WACA,MACA,WACA,OACA,OACA,UACA,aACA,QACA,WACA,QACA,OACA,QACA,OACA,UACA,QACA,MACA,SACA,OACA,QACA,UACA,WACA,QACA,OACA,SACA,SACA,QACA,QACA,UAGWI,EAAMJ,EAAO,CACxB,gBACA,aACA,WACA,qBACA,SACA,gBACA,gBACA,UACA,gBACA,iBACA,QACA,OACA,KACA,QACA,OACA,YACA,YACA,QACA,sBACA,8BACA,gBACA,kBACA,KACA,KACA,IACA,KACA,KACA,kBACA,YACA,UACA,UACA,MACA,WACA,YACA,MACA,OACA,eACA,YACA,SACA,cACA,cACA,gBACA,cACA,YACA,mBACA,eACA,aACA,eACA,cACA,KACA,KACA,KACA,KACA,aACA,WACA,gBACA,oBACA,SACA,OACA,KACA,kBACA,KACA,MACA,IACA,KACA,KACA,KACA,KACA,UACA,YACA,aACA,WACA,OACA,eACA,iBACA,eACA,mBACA,iBACA,QACA,aACA,aACA,eACA,eACA,cACA,cACA,mBACA,YACA,MACA,OACA,QACA,SACA,OACA,MACA,OACA,aACA,SACA,WACA,UACA,QACA,SACA,cACA,SACA,WACA,cACA,OACA,aACA,sBACA,mBACA,eACA,SACA,gBACA,sBACA,iBACA,IACA,KACA,KACA,SACA,OACA,OACA,cACA,YACA,UACA,SACA,SACA,QACA,OACA,kBACA,mBACA,mBACA,eACA,eACA,cACA,aACA,eACA,mBACA,oBACA,iBACA,kBACA,oBACA,iBACA,SACA,eACA,QACA,eACA,WACA,UACA,UACA,YACA,cACA,kBACA,iBACA,aACA,OACA,KACA,KACA,UACA,SACA,UACA,aACA,UACA,aACA,gBACA,gBACA,QACA,eACA,OACA,eACA,mBACA,mBACA,IACA,KACA,KACA,QACA,IACA,KACA,KACA,IACA,eAGWM,EAASN,EAAO,CAC3B,SACA,cACA,QACA,WACA,QACA,eACA,cACA,aACA,aACA,QACA,MACA,UACA,eACA,QACA,QACA,SACA,OACA,KACA,UACA,SACA,gBACA,SACA,SACA,iBACA,YACA,WACA,cACA,UACA,UACA,gBACA,WACA,WACA,OACA,WACA,WACA,aACA,UACA,SACA,SACA,cACA,gBACA,uBACA,YACA,YACA,aACA,WACA,iBACA,iBACA,YACA,UACA,QACA,UAGWQ,EAAMR,EAAO,CACxB,aACA,SACA,cACA,YACA,gBCpVMS,EAAmCR,OAAnCQ,eAAgBC,EAAmBT,OAAnBS,eAClBC,GAA6B,oBAAZC,SAA2BA,SAA5CD,MASN,SAAgBE,EAASC,EAAKC,GACxBL,GAIaI,EAAAA,EAAK,MAIfE,IADHA,IAAAA,EAAID,EAAMxB,OACPyB,KAAK,CACNC,IAAAA,EAAUF,EAAMC,GAChB,GAAmB,iBAAZC,EAAsB,CACzBC,IAAAA,EAAYD,EAAQE,cACtBD,IAAcD,IAEXhB,OAAOmB,SAASL,KACbC,EAAAA,GAAKE,GAGHA,EAAAA,GAIVD,EAAAA,IAAW,EAGVH,OAAAA,EAIT,SAAgBO,EAAMC,GACdC,IAAAA,EAAY,GAEdC,OAAJ,EACKA,IAAAA,KAAYF,EACXX,EAAMF,EAAgBa,EAAQ,CAACE,MACvBA,EAAAA,GAAYF,EAAOE,IAI1B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","file":"app.7eb818f0.js","sourceRoot":"..\\src","sourcesContent":["export default class Store {\r\n  get todoList() {\r\n    return JSON.parse(localStorage.getItem('to-do-app-js-list')) || []\r\n  }\r\n\r\n  set todoList(todos) {\r\n    localStorage.setItem('to-do-app-js-list', JSON.stringify(todos))\r\n  }\r\n}","export default class TodoList {\r\n  constructor(todos) {\r\n    this.todos = todos\r\n  }\r\n\r\n  setItems(items) {\r\n    this.todos = [ ...items ]\r\n  }\r\n\r\n  addItem(name, completed) {\r\n    const item = { id: Date.now(), name, completed }\r\n\r\n    this.todos.push(item)\r\n    \r\n    console.table(this.todos)\r\n\r\n    return item\r\n  }\r\n\r\n  removeItem(id) {\r\n    for (let i = 0; i < this.todos.length; i++) {\r\n      if (this.todos[i].id === id) {\r\n        this.todos.splice(i, 1)\r\n        break\r\n      }\r\n    }\r\n    \r\n    console.table(this.todos)\r\n  }\r\n\r\n  toggleItemStatus(id) {\r\n    let isCompleted = null\r\n\r\n    for (let i = 0; i < this.todos.length; i++) {\r\n      if (this.todos[i].id === id) {\r\n        this.todos[i].completed = !this.todos[i].completed\r\n        isCompleted = this.todos[i].completed\r\n        break\r\n      }\r\n    }\r\n\r\n    console.table(this.todos)\r\n\r\n    return isCompleted\r\n  }\r\n\r\n  updateItemName(id, newName) {\r\n    for (let i = 0; i < this.todos.length; i++) {\r\n      if (this.todos[i].id === id) {\r\n        this.todos[i].name = newName\r\n        break\r\n      }\r\n    }\r\n    \r\n    console.table(this.todos)\r\n  }\r\n\r\n  reorderItems(newIndices) {\r\n    const reorderedTodos = newIndices.map(index => this.todos[index])\r\n\r\n    this.setItems(reorderedTodos)\r\n\r\n    console.table(this.todos)\r\n  }\r\n}","import * as TAGS from './tags';\nimport * as ATTRS from './attrs';\nimport { addToSet, clone } from './utils';\nimport * as EXPRESSIONS from './regexp';\n\nlet { apply } = typeof Reflect !== 'undefined' && Reflect;\nconst { slice: arraySlice } = Array.prototype;\nconst { freeze } = Object;\nconst getGlobal = () => (typeof window === 'undefined' ? null : window);\n\nif (!apply) {\n  apply = function(fun, thisValue, args) {\n    return fun.apply(thisValue, args);\n  };\n}\n\n/**\n * Creates a no-op policy for internal use only.\n * Don't export this function outside this module!\n * @param {?TrustedTypePolicyFactory} trustedTypes The policy factory.\n * @param {Document} document The document object (to determine policy name suffix)\n * @return {?TrustedTypePolicy} The policy created (or null, if Trusted Types\n * are not supported).\n */\nconst _createTrustedTypesPolicy = function(trustedTypes, document) {\n  if (\n    typeof trustedTypes !== 'object' ||\n    typeof trustedTypes.createPolicy !== 'function'\n  ) {\n    return null;\n  }\n\n  // Allow the callers to control the unique policy name\n  // by adding a data-tt-policy-suffix to the script element with the DOMPurify.\n  // Policy creation with duplicate names throws in Trusted Types.\n  let suffix = null;\n  const ATTR_NAME = 'data-tt-policy-suffix';\n  if (\n    document.currentScript &&\n    document.currentScript.hasAttribute(ATTR_NAME)\n  ) {\n    suffix = document.currentScript.getAttribute(ATTR_NAME);\n  }\n\n  const policyName = 'dompurify' + (suffix ? '#' + suffix : '');\n\n  try {\n    return trustedTypes.createPolicy(policyName, {\n      createHTML(html) {\n        return html;\n      },\n    });\n  } catch (error) {\n    // Policy creation failed (most likely another DOMPurify script has\n    // already run). Skip creating the policy, as this will only cause errors\n    // if TT are enforced.\n    console.warn(\n      'TrustedTypes policy ' + policyName + ' could not be created.'\n    );\n    return null;\n  }\n};\n\nfunction createDOMPurify(window = getGlobal()) {\n  const DOMPurify = root => createDOMPurify(root);\n\n  /**\n   * Version label, exposed for easier checks\n   * if DOMPurify is up to date or not\n   */\n  DOMPurify.version = VERSION;\n\n  /**\n   * Array of elements that DOMPurify removed during sanitation.\n   * Empty if nothing was removed.\n   */\n  DOMPurify.removed = [];\n\n  if (!window || !window.document || window.document.nodeType !== 9) {\n    // Not running in a browser, provide a factory function\n    // so that you can pass your own Window\n    DOMPurify.isSupported = false;\n\n    return DOMPurify;\n  }\n\n  const originalDocument = window.document;\n  let useDOMParser = false;\n  let removeTitle = false;\n\n  let { document } = window;\n  const {\n    DocumentFragment,\n    HTMLTemplateElement,\n    Node,\n    NodeFilter,\n    NamedNodeMap = window.NamedNodeMap || window.MozNamedAttrMap,\n    Text,\n    Comment,\n    DOMParser,\n    TrustedTypes,\n  } = window;\n\n  // As per issue #47, the web-components registry is inherited by a\n  // new document created via createHTMLDocument. As per the spec\n  // (http://w3c.github.io/webcomponents/spec/custom/#creating-and-passing-registries)\n  // a new empty registry is used when creating a template contents owner\n  // document, so we use that as our parent document to ensure nothing\n  // is inherited.\n  if (typeof HTMLTemplateElement === 'function') {\n    const template = document.createElement('template');\n    if (template.content && template.content.ownerDocument) {\n      document = template.content.ownerDocument;\n    }\n  }\n\n  const trustedTypesPolicy = _createTrustedTypesPolicy(\n    TrustedTypes,\n    originalDocument\n  );\n  const emptyHTML = trustedTypesPolicy ? trustedTypesPolicy.createHTML('') : '';\n\n  const {\n    implementation,\n    createNodeIterator,\n    getElementsByTagName,\n    createDocumentFragment,\n  } = document;\n  const { importNode } = originalDocument;\n\n  let hooks = {};\n\n  /**\n   * Expose whether this browser supports running the full DOMPurify.\n   */\n  DOMPurify.isSupported =\n    implementation &&\n    typeof implementation.createHTMLDocument !== 'undefined' &&\n    document.documentMode !== 9;\n\n  const {\n    MUSTACHE_EXPR,\n    ERB_EXPR,\n    DATA_ATTR,\n    ARIA_ATTR,\n    IS_SCRIPT_OR_DATA,\n    ATTR_WHITESPACE,\n  } = EXPRESSIONS;\n\n  let { IS_ALLOWED_URI } = EXPRESSIONS;\n  /**\n   * We consider the elements and attributes below to be safe. Ideally\n   * don't add any new ones but feel free to remove unwanted ones.\n   */\n\n  /* allowed element names */\n  let ALLOWED_TAGS = null;\n  const DEFAULT_ALLOWED_TAGS = addToSet({}, [\n    ...TAGS.html,\n    ...TAGS.svg,\n    ...TAGS.svgFilters,\n    ...TAGS.mathMl,\n    ...TAGS.text,\n  ]);\n\n  /* Allowed attribute names */\n  let ALLOWED_ATTR = null;\n  const DEFAULT_ALLOWED_ATTR = addToSet({}, [\n    ...ATTRS.html,\n    ...ATTRS.svg,\n    ...ATTRS.mathMl,\n    ...ATTRS.xml,\n  ]);\n\n  /* Explicitly forbidden tags (overrides ALLOWED_TAGS/ADD_TAGS) */\n  let FORBID_TAGS = null;\n\n  /* Explicitly forbidden attributes (overrides ALLOWED_ATTR/ADD_ATTR) */\n  let FORBID_ATTR = null;\n\n  /* Decide if ARIA attributes are okay */\n  let ALLOW_ARIA_ATTR = true;\n\n  /* Decide if custom data attributes are okay */\n  let ALLOW_DATA_ATTR = true;\n\n  /* Decide if unknown protocols are okay */\n  let ALLOW_UNKNOWN_PROTOCOLS = false;\n\n  /* Output should be safe for jQuery's $() factory? */\n  let SAFE_FOR_JQUERY = false;\n\n  /* Output should be safe for common template engines.\n   * This means, DOMPurify removes data attributes, mustaches and ERB\n   */\n  let SAFE_FOR_TEMPLATES = false;\n\n  /* Decide if document with <html>... should be returned */\n  let WHOLE_DOCUMENT = false;\n\n  /* Track whether config is already set on this instance of DOMPurify. */\n  let SET_CONFIG = false;\n\n  /* Decide if all elements (e.g. style, script) must be children of\n   * document.body. By default, browsers might move them to document.head */\n  let FORCE_BODY = false;\n\n  /* Decide if a DOM `HTMLBodyElement` should be returned, instead of a html\n   * string (or a TrustedHTML object if Trusted Types are supported).\n   * If `WHOLE_DOCUMENT` is enabled a `HTMLHtmlElement` will be returned instead\n   */\n  let RETURN_DOM = false;\n\n  /* Decide if a DOM `DocumentFragment` should be returned, instead of a html\n   * string  (or a TrustedHTML object if Trusted Types are supported) */\n  let RETURN_DOM_FRAGMENT = false;\n\n  /* If `RETURN_DOM` or `RETURN_DOM_FRAGMENT` is enabled, decide if the returned DOM\n   * `Node` is imported into the current `Document`. If this flag is not enabled the\n   * `Node` will belong (its ownerDocument) to a fresh `HTMLDocument`, created by\n   * DOMPurify. */\n  let RETURN_DOM_IMPORT = false;\n\n  /* Output should be free from DOM clobbering attacks? */\n  let SANITIZE_DOM = true;\n\n  /* Keep element content when removing element? */\n  let KEEP_CONTENT = true;\n\n  /* If a `Node` is passed to sanitize(), then performs sanitization in-place instead\n   * of importing it into a new Document and returning a sanitized copy */\n  let IN_PLACE = false;\n\n  /* Allow usage of profiles like html, svg and mathMl */\n  let USE_PROFILES = {};\n\n  /* Tags to ignore content of when KEEP_CONTENT is true */\n  const FORBID_CONTENTS = addToSet({}, [\n    'audio',\n    'head',\n    'math',\n    'script',\n    'style',\n    'template',\n    'svg',\n    'video',\n  ]);\n\n  /* Tags that are safe for data: URIs */\n  const DATA_URI_TAGS = addToSet({}, [\n    'audio',\n    'video',\n    'img',\n    'source',\n    'image',\n  ]);\n\n  /* Attributes safe for values like \"javascript:\" */\n  let URI_SAFE_ATTRIBUTES = null;\n  const DEFAULT_URI_SAFE_ATTRIBUTES = addToSet({}, [\n    'alt',\n    'class',\n    'for',\n    'id',\n    'label',\n    'name',\n    'pattern',\n    'placeholder',\n    'summary',\n    'title',\n    'value',\n    'style',\n    'xmlns',\n  ]);\n\n  /* Keep a reference to config to pass to hooks */\n  let CONFIG = null;\n\n  /* Ideally, do not touch anything below this line */\n  /* ______________________________________________ */\n\n  const formElement = document.createElement('form');\n\n  /**\n   * _parseConfig\n   *\n   * @param  {Object} cfg optional config literal\n   */\n  // eslint-disable-next-line complexity\n  const _parseConfig = function(cfg) {\n    if (CONFIG && CONFIG === cfg) {\n      return;\n    }\n\n    /* Shield configuration object from tampering */\n    if (!cfg || typeof cfg !== 'object') {\n      cfg = {};\n    }\n\n    /* Set configuration parameters */\n    ALLOWED_TAGS =\n      'ALLOWED_TAGS' in cfg\n        ? addToSet({}, cfg.ALLOWED_TAGS)\n        : DEFAULT_ALLOWED_TAGS;\n    ALLOWED_ATTR =\n      'ALLOWED_ATTR' in cfg\n        ? addToSet({}, cfg.ALLOWED_ATTR)\n        : DEFAULT_ALLOWED_ATTR;\n    URI_SAFE_ATTRIBUTES =\n      'ADD_URI_SAFE_ATTR' in cfg\n        ? addToSet({}, cfg.ADD_URI_SAFE_ATTR)\n        : DEFAULT_URI_SAFE_ATTRIBUTES;\n    FORBID_TAGS = 'FORBID_TAGS' in cfg ? addToSet({}, cfg.FORBID_TAGS) : {};\n    FORBID_ATTR = 'FORBID_ATTR' in cfg ? addToSet({}, cfg.FORBID_ATTR) : {};\n    USE_PROFILES = 'USE_PROFILES' in cfg ? cfg.USE_PROFILES : false;\n    ALLOW_ARIA_ATTR = cfg.ALLOW_ARIA_ATTR !== false; // Default true\n    ALLOW_DATA_ATTR = cfg.ALLOW_DATA_ATTR !== false; // Default true\n    ALLOW_UNKNOWN_PROTOCOLS = cfg.ALLOW_UNKNOWN_PROTOCOLS || false; // Default false\n    SAFE_FOR_JQUERY = cfg.SAFE_FOR_JQUERY || false; // Default false\n    SAFE_FOR_TEMPLATES = cfg.SAFE_FOR_TEMPLATES || false; // Default false\n    WHOLE_DOCUMENT = cfg.WHOLE_DOCUMENT || false; // Default false\n    RETURN_DOM = cfg.RETURN_DOM || false; // Default false\n    RETURN_DOM_FRAGMENT = cfg.RETURN_DOM_FRAGMENT || false; // Default false\n    RETURN_DOM_IMPORT = cfg.RETURN_DOM_IMPORT || false; // Default false\n    FORCE_BODY = cfg.FORCE_BODY || false; // Default false\n    SANITIZE_DOM = cfg.SANITIZE_DOM !== false; // Default true\n    KEEP_CONTENT = cfg.KEEP_CONTENT !== false; // Default true\n    IN_PLACE = cfg.IN_PLACE || false; // Default false\n\n    IS_ALLOWED_URI = cfg.ALLOWED_URI_REGEXP || IS_ALLOWED_URI;\n\n    if (SAFE_FOR_TEMPLATES) {\n      ALLOW_DATA_ATTR = false;\n    }\n\n    if (RETURN_DOM_FRAGMENT) {\n      RETURN_DOM = true;\n    }\n\n    /* Parse profile info */\n    if (USE_PROFILES) {\n      ALLOWED_TAGS = addToSet({}, [...TAGS.text]);\n      ALLOWED_ATTR = [];\n      if (USE_PROFILES.html === true) {\n        addToSet(ALLOWED_TAGS, TAGS.html);\n        addToSet(ALLOWED_ATTR, ATTRS.html);\n      }\n\n      if (USE_PROFILES.svg === true) {\n        addToSet(ALLOWED_TAGS, TAGS.svg);\n        addToSet(ALLOWED_ATTR, ATTRS.svg);\n        addToSet(ALLOWED_ATTR, ATTRS.xml);\n      }\n\n      if (USE_PROFILES.svgFilters === true) {\n        addToSet(ALLOWED_TAGS, TAGS.svgFilters);\n        addToSet(ALLOWED_ATTR, ATTRS.svg);\n        addToSet(ALLOWED_ATTR, ATTRS.xml);\n      }\n\n      if (USE_PROFILES.mathMl === true) {\n        addToSet(ALLOWED_TAGS, TAGS.mathMl);\n        addToSet(ALLOWED_ATTR, ATTRS.mathMl);\n        addToSet(ALLOWED_ATTR, ATTRS.xml);\n      }\n    }\n\n    /* Merge configuration parameters */\n    if (cfg.ADD_TAGS) {\n      if (ALLOWED_TAGS === DEFAULT_ALLOWED_TAGS) {\n        ALLOWED_TAGS = clone(ALLOWED_TAGS);\n      }\n\n      addToSet(ALLOWED_TAGS, cfg.ADD_TAGS);\n    }\n\n    if (cfg.ADD_ATTR) {\n      if (ALLOWED_ATTR === DEFAULT_ALLOWED_ATTR) {\n        ALLOWED_ATTR = clone(ALLOWED_ATTR);\n      }\n\n      addToSet(ALLOWED_ATTR, cfg.ADD_ATTR);\n    }\n\n    if (cfg.ADD_URI_SAFE_ATTR) {\n      addToSet(URI_SAFE_ATTRIBUTES, cfg.ADD_URI_SAFE_ATTR);\n    }\n\n    /* Add #text in case KEEP_CONTENT is set to true */\n    if (KEEP_CONTENT) {\n      ALLOWED_TAGS['#text'] = true;\n    }\n\n    /* Add html, head and body to ALLOWED_TAGS in case WHOLE_DOCUMENT is true */\n    if (WHOLE_DOCUMENT) {\n      addToSet(ALLOWED_TAGS, ['html', 'head', 'body']);\n    }\n\n    /* Add tbody to ALLOWED_TAGS in case tables are permitted, see #286 */\n    if (ALLOWED_TAGS.table) {\n      addToSet(ALLOWED_TAGS, ['tbody']);\n    }\n\n    // Prevent further manipulation of configuration.\n    // Not available in IE8, Safari 5, etc.\n    if (freeze) {\n      freeze(cfg);\n    }\n\n    CONFIG = cfg;\n  };\n\n  /**\n   * _forceRemove\n   *\n   * @param  {Node} node a DOM node\n   */\n  const _forceRemove = function(node) {\n    DOMPurify.removed.push({ element: node });\n    try {\n      node.parentNode.removeChild(node);\n    } catch (error) {\n      node.outerHTML = emptyHTML;\n    }\n  };\n\n  /**\n   * _removeAttribute\n   *\n   * @param  {String} name an Attribute name\n   * @param  {Node} node a DOM node\n   */\n  const _removeAttribute = function(name, node) {\n    try {\n      DOMPurify.removed.push({\n        attribute: node.getAttributeNode(name),\n        from: node,\n      });\n    } catch (error) {\n      DOMPurify.removed.push({\n        attribute: null,\n        from: node,\n      });\n    }\n\n    node.removeAttribute(name);\n  };\n\n  /**\n   * _initDocument\n   *\n   * @param  {String} dirty a string of dirty markup\n   * @return {Document} a DOM, filled with the dirty markup\n   */\n  const _initDocument = function(dirty) {\n    /* Create a HTML document */\n    let doc;\n    let leadingWhitespace;\n\n    if (FORCE_BODY) {\n      dirty = '<remove></remove>' + dirty;\n    } else {\n      /* If FORCE_BODY isn't used, leading whitespace needs to be preserved manually */\n      const matches = dirty.match(/^[\\s]+/);\n      leadingWhitespace = matches && matches[0];\n      if (leadingWhitespace) {\n        dirty = dirty.slice(leadingWhitespace.length);\n      }\n    }\n\n    /* Use DOMParser to workaround Firefox bug (see comment below) */\n    if (useDOMParser) {\n      try {\n        doc = new DOMParser().parseFromString(dirty, 'text/html');\n      } catch (error) {}\n    }\n\n    /* Remove title to fix a mXSS bug in older MS Edge */\n    if (removeTitle) {\n      addToSet(FORBID_TAGS, ['title']);\n    }\n\n    /* Otherwise use createHTMLDocument, because DOMParser is unsafe in\n    Safari (see comment below) */\n    if (!doc || !doc.documentElement) {\n      doc = implementation.createHTMLDocument('');\n      const { body } = doc;\n      body.parentNode.removeChild(body.parentNode.firstElementChild);\n      body.outerHTML = trustedTypesPolicy\n        ? trustedTypesPolicy.createHTML(dirty)\n        : dirty;\n    }\n\n    if (leadingWhitespace) {\n      doc.body.insertBefore(\n        document.createTextNode(leadingWhitespace),\n        doc.body.childNodes[0] || null\n      );\n    }\n\n    /* Work on whole document or just its body */\n    return getElementsByTagName.call(doc, WHOLE_DOCUMENT ? 'html' : 'body')[0];\n  };\n\n  // Firefox uses a different parser for innerHTML rather than\n  // DOMParser (see https://bugzilla.mozilla.org/show_bug.cgi?id=1205631)\n  // which means that you *must* use DOMParser, otherwise the output may\n  // not be safe if used in a document.write context later.\n  //\n  // So we feature detect the Firefox bug and use the DOMParser if necessary.\n  //\n  // MS Edge, in older versions, is affected by an mXSS behavior. The second\n  // check tests for the behavior and fixes it if necessary.\n  if (DOMPurify.isSupported) {\n    (function() {\n      try {\n        const doc = _initDocument(\n          '<svg><p><style><img src=\"</style><img src=x onerror=1//\">'\n        );\n        if (doc.querySelector('svg img')) {\n          useDOMParser = true;\n        }\n      } catch (error) {}\n    })();\n\n    (function() {\n      try {\n        const doc = _initDocument('<x/><title>&lt;/title&gt;&lt;img&gt;');\n        if (doc.querySelector('title').innerHTML.match(/<\\/title/)) {\n          removeTitle = true;\n        }\n      } catch (error) {}\n    })();\n  }\n\n  /**\n   * _createIterator\n   *\n   * @param  {Document} root document/fragment to create iterator for\n   * @return {Iterator} iterator instance\n   */\n  const _createIterator = function(root) {\n    return createNodeIterator.call(\n      root.ownerDocument || root,\n      root,\n      NodeFilter.SHOW_ELEMENT | NodeFilter.SHOW_COMMENT | NodeFilter.SHOW_TEXT,\n      () => {\n        return NodeFilter.FILTER_ACCEPT;\n      },\n      false\n    );\n  };\n\n  /**\n   * _isClobbered\n   *\n   * @param  {Node} elm element to check for clobbering attacks\n   * @return {Boolean} true if clobbered, false if safe\n   */\n  const _isClobbered = function(elm) {\n    if (elm instanceof Text || elm instanceof Comment) {\n      return false;\n    }\n\n    if (\n      typeof elm.nodeName !== 'string' ||\n      typeof elm.textContent !== 'string' ||\n      typeof elm.removeChild !== 'function' ||\n      !(elm.attributes instanceof NamedNodeMap) ||\n      typeof elm.removeAttribute !== 'function' ||\n      typeof elm.setAttribute !== 'function'\n    ) {\n      return true;\n    }\n\n    return false;\n  };\n\n  /**\n   * _isNode\n   *\n   * @param  {Node} obj object to check whether it's a DOM node\n   * @return {Boolean} true is object is a DOM node\n   */\n  const _isNode = function(obj) {\n    return typeof Node === 'object'\n      ? obj instanceof Node\n      : obj &&\n          typeof obj === 'object' &&\n          typeof obj.nodeType === 'number' &&\n          typeof obj.nodeName === 'string';\n  };\n\n  /**\n   * _executeHook\n   * Execute user configurable hooks\n   *\n   * @param  {String} entryPoint  Name of the hook's entry point\n   * @param  {Node} currentNode node to work on with the hook\n   * @param  {Object} data additional hook parameters\n   */\n  const _executeHook = function(entryPoint, currentNode, data) {\n    if (!hooks[entryPoint]) {\n      return;\n    }\n\n    hooks[entryPoint].forEach(hook => {\n      hook.call(DOMPurify, currentNode, data, CONFIG);\n    });\n  };\n\n  /**\n   * _sanitizeElements\n   *\n   * @protect nodeName\n   * @protect textContent\n   * @protect removeChild\n   *\n   * @param   {Node} currentNode to check for permission to exist\n   * @return  {Boolean} true if node was killed, false if left alive\n   */\n  // eslint-disable-next-line complexity\n  const _sanitizeElements = function(currentNode) {\n    let content;\n\n    /* Execute a hook if present */\n    _executeHook('beforeSanitizeElements', currentNode, null);\n\n    /* Check if element is clobbered or can clobber */\n    if (_isClobbered(currentNode)) {\n      _forceRemove(currentNode);\n      return true;\n    }\n\n    /* Now let's check the element's type and name */\n    const tagName = currentNode.nodeName.toLowerCase();\n\n    /* Execute a hook if present */\n    _executeHook('uponSanitizeElement', currentNode, {\n      tagName,\n      allowedTags: ALLOWED_TAGS,\n    });\n\n    /* Remove element if anything forbids its presence */\n    if (!ALLOWED_TAGS[tagName] || FORBID_TAGS[tagName]) {\n      /* Keep content except for black-listed elements */\n      if (\n        KEEP_CONTENT &&\n        !FORBID_CONTENTS[tagName] &&\n        typeof currentNode.insertAdjacentHTML === 'function'\n      ) {\n        try {\n          const htmlToInsert = currentNode.innerHTML;\n          currentNode.insertAdjacentHTML(\n            'AfterEnd',\n            trustedTypesPolicy\n              ? trustedTypesPolicy.createHTML(htmlToInsert)\n              : htmlToInsert\n          );\n        } catch (error) {}\n      }\n\n      _forceRemove(currentNode);\n      return true;\n    }\n\n    /* Remove in case a noscript/noembed XSS is suspected */\n    if (tagName === 'noscript' && currentNode.innerHTML.match(/<\\/noscript/i)) {\n      _forceRemove(currentNode);\n      return true;\n    }\n\n    if (tagName === 'noembed' && currentNode.innerHTML.match(/<\\/noembed/i)) {\n      _forceRemove(currentNode);\n      return true;\n    }\n\n    /* Convert markup to cover jQuery behavior */\n    if (\n      SAFE_FOR_JQUERY &&\n      !currentNode.firstElementChild &&\n      (!currentNode.content || !currentNode.content.firstElementChild) &&\n      /</g.test(currentNode.textContent)\n    ) {\n      DOMPurify.removed.push({ element: currentNode.cloneNode() });\n      if (currentNode.innerHTML) {\n        currentNode.innerHTML = currentNode.innerHTML.replace(/</g, '&lt;');\n      } else {\n        currentNode.innerHTML = currentNode.textContent.replace(/</g, '&lt;');\n      }\n    }\n\n    /* Sanitize element content to be template-safe */\n    if (SAFE_FOR_TEMPLATES && currentNode.nodeType === 3) {\n      /* Get the element's text content */\n      content = currentNode.textContent;\n      content = content.replace(MUSTACHE_EXPR, ' ');\n      content = content.replace(ERB_EXPR, ' ');\n      if (currentNode.textContent !== content) {\n        DOMPurify.removed.push({ element: currentNode.cloneNode() });\n        currentNode.textContent = content;\n      }\n    }\n\n    /* Execute a hook if present */\n    _executeHook('afterSanitizeElements', currentNode, null);\n\n    return false;\n  };\n\n  /**\n   * _isValidAttribute\n   *\n   * @param  {string} lcTag Lowercase tag name of containing element.\n   * @param  {string} lcName Lowercase attribute name.\n   * @param  {string} value Attribute value.\n   * @return {Boolean} Returns true if `value` is valid, otherwise false.\n   */\n  // eslint-disable-next-line complexity\n  const _isValidAttribute = function(lcTag, lcName, value) {\n    /* Make sure attribute cannot clobber */\n    if (\n      SANITIZE_DOM &&\n      (lcName === 'id' || lcName === 'name') &&\n      (value in document || value in formElement)\n    ) {\n      return false;\n    }\n\n    /* Allow valid data-* attributes: At least one character after \"-\"\n        (https://html.spec.whatwg.org/multipage/dom.html#embedding-custom-non-visible-data-with-the-data-*-attributes)\n        XML-compatible (https://html.spec.whatwg.org/multipage/infrastructure.html#xml-compatible and http://www.w3.org/TR/xml/#d0e804)\n        We don't need to check the value; it's always URI safe. */\n    if (ALLOW_DATA_ATTR && DATA_ATTR.test(lcName)) {\n      // This attribute is safe\n    } else if (ALLOW_ARIA_ATTR && ARIA_ATTR.test(lcName)) {\n      // This attribute is safe\n      /* Otherwise, check the name is permitted */\n    } else if (!ALLOWED_ATTR[lcName] || FORBID_ATTR[lcName]) {\n      return false;\n\n      /* Check value is safe. First, is attr inert? If so, is safe */\n    } else if (URI_SAFE_ATTRIBUTES[lcName]) {\n      // This attribute is safe\n      /* Check no script, data or unknown possibly unsafe URI\n        unless we know URI values are safe for that attribute */\n    } else if (IS_ALLOWED_URI.test(value.replace(ATTR_WHITESPACE, ''))) {\n      // This attribute is safe\n      /* Keep image data URIs alive if src/xlink:href is allowed */\n      /* Further prevent gadget XSS for dynamically built script tags */\n    } else if (\n      (lcName === 'src' || lcName === 'xlink:href') &&\n      lcTag !== 'script' &&\n      value.indexOf('data:') === 0 &&\n      DATA_URI_TAGS[lcTag]\n    ) {\n      // This attribute is safe\n      /* Allow unknown protocols: This provides support for links that\n        are handled by protocol handlers which may be unknown ahead of\n        time, e.g. fb:, spotify: */\n    } else if (\n      ALLOW_UNKNOWN_PROTOCOLS &&\n      !IS_SCRIPT_OR_DATA.test(value.replace(ATTR_WHITESPACE, ''))\n    ) {\n      // This attribute is safe\n      /* Check for binary attributes */\n      // eslint-disable-next-line no-negated-condition\n    } else if (!value) {\n      // Binary attributes are safe at this point\n      /* Anything else, presume unsafe, do not add it back */\n    } else {\n      return false;\n    }\n\n    return true;\n  };\n\n  /**\n   * _sanitizeAttributes\n   *\n   * @protect attributes\n   * @protect nodeName\n   * @protect removeAttribute\n   * @protect setAttribute\n   *\n   * @param  {Node} currentNode to sanitize\n   */\n  const _sanitizeAttributes = function(currentNode) {\n    let attr;\n    let value;\n    let lcName;\n    let idAttr;\n    let l;\n    /* Execute a hook if present */\n    _executeHook('beforeSanitizeAttributes', currentNode, null);\n\n    let { attributes } = currentNode;\n\n    /* Check if we have attributes; if not we might have a text node */\n    if (!attributes) {\n      return;\n    }\n\n    const hookEvent = {\n      attrName: '',\n      attrValue: '',\n      keepAttr: true,\n      allowedAttributes: ALLOWED_ATTR,\n    };\n    l = attributes.length;\n\n    /* Go backwards over all attributes; safely remove bad ones */\n    while (l--) {\n      attr = attributes[l];\n      const { name, namespaceURI } = attr;\n      value = attr.value.trim();\n      lcName = name.toLowerCase();\n\n      /* Execute a hook if present */\n      hookEvent.attrName = lcName;\n      hookEvent.attrValue = value;\n      hookEvent.keepAttr = true;\n      _executeHook('uponSanitizeAttribute', currentNode, hookEvent);\n      value = hookEvent.attrValue;\n\n      /* Remove attribute */\n      // Safari (iOS + Mac), last tested v8.0.5, crashes if you try to\n      // remove a \"name\" attribute from an <img> tag that has an \"id\"\n      // attribute at the time.\n      if (\n        lcName === 'name' &&\n        currentNode.nodeName === 'IMG' &&\n        attributes.id\n      ) {\n        idAttr = attributes.id;\n        attributes = apply(arraySlice, attributes, []);\n        _removeAttribute('id', currentNode);\n        _removeAttribute(name, currentNode);\n        if (attributes.indexOf(idAttr) > l) {\n          currentNode.setAttribute('id', idAttr.value);\n        }\n      } else if (\n        // This works around a bug in Safari, where input[type=file]\n        // cannot be dynamically set after type has been removed\n        currentNode.nodeName === 'INPUT' &&\n        lcName === 'type' &&\n        value === 'file' &&\n        hookEvent.keepAttr &&\n        (ALLOWED_ATTR[lcName] || !FORBID_ATTR[lcName])\n      ) {\n        continue;\n      } else {\n        // This avoids a crash in Safari v9.0 with double-ids.\n        // The trick is to first set the id to be empty and then to\n        // remove the attribute\n        if (name === 'id') {\n          currentNode.setAttribute(name, '');\n        }\n\n        _removeAttribute(name, currentNode);\n      }\n\n      /* Did the hooks approve of the attribute? */\n      if (!hookEvent.keepAttr) {\n        continue;\n      }\n\n      /* Sanitize attribute content to be template-safe */\n      if (SAFE_FOR_TEMPLATES) {\n        value = value.replace(MUSTACHE_EXPR, ' ');\n        value = value.replace(ERB_EXPR, ' ');\n      }\n\n      /* Is `value` valid for this attribute? */\n      const lcTag = currentNode.nodeName.toLowerCase();\n      if (!_isValidAttribute(lcTag, lcName, value)) {\n        continue;\n      }\n\n      /* Handle invalid data-* attribute set by try-catching it */\n      try {\n        if (namespaceURI) {\n          currentNode.setAttributeNS(namespaceURI, name, value);\n        } else {\n          /* Fallback to setAttribute() for browser-unrecognized namespaces e.g. \"x-schema\". */\n          currentNode.setAttribute(name, value);\n        }\n\n        DOMPurify.removed.pop();\n      } catch (error) {}\n    }\n\n    /* Execute a hook if present */\n    _executeHook('afterSanitizeAttributes', currentNode, null);\n  };\n\n  /**\n   * _sanitizeShadowDOM\n   *\n   * @param  {DocumentFragment} fragment to iterate over recursively\n   */\n  const _sanitizeShadowDOM = function(fragment) {\n    let shadowNode;\n    const shadowIterator = _createIterator(fragment);\n\n    /* Execute a hook if present */\n    _executeHook('beforeSanitizeShadowDOM', fragment, null);\n\n    while ((shadowNode = shadowIterator.nextNode())) {\n      /* Execute a hook if present */\n      _executeHook('uponSanitizeShadowNode', shadowNode, null);\n\n      /* Sanitize tags and elements */\n      if (_sanitizeElements(shadowNode)) {\n        continue;\n      }\n\n      /* Deep shadow DOM detected */\n      if (shadowNode.content instanceof DocumentFragment) {\n        _sanitizeShadowDOM(shadowNode.content);\n      }\n\n      /* Check attributes, sanitize if necessary */\n      _sanitizeAttributes(shadowNode);\n    }\n\n    /* Execute a hook if present */\n    _executeHook('afterSanitizeShadowDOM', fragment, null);\n  };\n\n  /**\n   * Sanitize\n   * Public method providing core sanitation functionality\n   *\n   * @param {String|Node} dirty string or DOM node\n   * @param {Object} configuration object\n   */\n  // eslint-disable-next-line complexity\n  DOMPurify.sanitize = function(dirty, cfg) {\n    let body;\n    let importedNode;\n    let currentNode;\n    let oldNode;\n    let returnNode;\n    /* Make sure we have a string to sanitize.\n      DO NOT return early, as this will return the wrong type if\n      the user has requested a DOM object rather than a string */\n    if (!dirty) {\n      dirty = '<!-->';\n    }\n\n    /* Stringify, in case dirty is an object */\n    if (typeof dirty !== 'string' && !_isNode(dirty)) {\n      // eslint-disable-next-line no-negated-condition\n      if (typeof dirty.toString !== 'function') {\n        throw new TypeError('toString is not a function');\n      } else {\n        dirty = dirty.toString();\n        if (typeof dirty !== 'string') {\n          throw new TypeError('dirty is not a string, aborting');\n        }\n      }\n    }\n\n    /* Check we can run. Otherwise fall back or ignore */\n    if (!DOMPurify.isSupported) {\n      if (\n        typeof window.toStaticHTML === 'object' ||\n        typeof window.toStaticHTML === 'function'\n      ) {\n        if (typeof dirty === 'string') {\n          return window.toStaticHTML(dirty);\n        }\n\n        if (_isNode(dirty)) {\n          return window.toStaticHTML(dirty.outerHTML);\n        }\n      }\n\n      return dirty;\n    }\n\n    /* Assign config vars */\n    if (!SET_CONFIG) {\n      _parseConfig(cfg);\n    }\n\n    /* Clean up removed elements */\n    DOMPurify.removed = [];\n\n    if (IN_PLACE) {\n      /* No special handling necessary for in-place sanitization */\n    } else if (dirty instanceof Node) {\n      /* If dirty is a DOM element, append to an empty document to avoid\n         elements being stripped by the parser */\n      body = _initDocument('<!-->');\n      importedNode = body.ownerDocument.importNode(dirty, true);\n      if (importedNode.nodeType === 1 && importedNode.nodeName === 'BODY') {\n        /* Node is already a body, use as is */\n        body = importedNode;\n      } else if (importedNode.nodeName === 'HTML') {\n        body = importedNode;\n      } else {\n        // eslint-disable-next-line unicorn/prefer-node-append\n        body.appendChild(importedNode);\n      }\n    } else {\n      /* Exit directly if we have nothing to do */\n      if (\n        !RETURN_DOM &&\n        !SAFE_FOR_TEMPLATES &&\n        !WHOLE_DOCUMENT &&\n        dirty.indexOf('<') === -1\n      ) {\n        return trustedTypesPolicy\n          ? trustedTypesPolicy.createHTML(dirty)\n          : dirty;\n      }\n\n      /* Initialize the document to work on */\n      body = _initDocument(dirty);\n\n      /* Check we have a DOM node from the data */\n      if (!body) {\n        return RETURN_DOM ? null : emptyHTML;\n      }\n    }\n\n    /* Remove first element node (ours) if FORCE_BODY is set */\n    if (body && FORCE_BODY) {\n      _forceRemove(body.firstChild);\n    }\n\n    /* Get node iterator */\n    const nodeIterator = _createIterator(IN_PLACE ? dirty : body);\n\n    /* Now start iterating over the created document */\n    while ((currentNode = nodeIterator.nextNode())) {\n      /* Fix IE's strange behavior with manipulated textNodes #89 */\n      if (currentNode.nodeType === 3 && currentNode === oldNode) {\n        continue;\n      }\n\n      /* Sanitize tags and elements */\n      if (_sanitizeElements(currentNode)) {\n        continue;\n      }\n\n      /* Shadow DOM detected, sanitize it */\n      if (currentNode.content instanceof DocumentFragment) {\n        _sanitizeShadowDOM(currentNode.content);\n      }\n\n      /* Check attributes, sanitize if necessary */\n      _sanitizeAttributes(currentNode);\n\n      oldNode = currentNode;\n    }\n\n    oldNode = null;\n\n    /* If we sanitized `dirty` in-place, return it. */\n    if (IN_PLACE) {\n      return dirty;\n    }\n\n    /* Return sanitized string or DOM */\n    if (RETURN_DOM) {\n      if (RETURN_DOM_FRAGMENT) {\n        returnNode = createDocumentFragment.call(body.ownerDocument);\n\n        while (body.firstChild) {\n          // eslint-disable-next-line unicorn/prefer-node-append\n          returnNode.appendChild(body.firstChild);\n        }\n      } else {\n        returnNode = body;\n      }\n\n      if (RETURN_DOM_IMPORT) {\n        /* AdoptNode() is not used because internal state is not reset\n               (e.g. the past names map of a HTMLFormElement), this is safe\n               in theory but we would rather not risk another attack vector.\n               The state that is cloned by importNode() is explicitly defined\n               by the specs. */\n        returnNode = importNode.call(originalDocument, returnNode, true);\n      }\n\n      return returnNode;\n    }\n\n    let serializedHTML = WHOLE_DOCUMENT ? body.outerHTML : body.innerHTML;\n\n    /* Sanitize final string template-safe */\n    if (SAFE_FOR_TEMPLATES) {\n      serializedHTML = serializedHTML.replace(MUSTACHE_EXPR, ' ');\n      serializedHTML = serializedHTML.replace(ERB_EXPR, ' ');\n    }\n\n    return trustedTypesPolicy\n      ? trustedTypesPolicy.createHTML(serializedHTML)\n      : serializedHTML;\n  };\n\n  /**\n   * Public method to set the configuration once\n   * setConfig\n   *\n   * @param {Object} cfg configuration object\n   */\n  DOMPurify.setConfig = function(cfg) {\n    _parseConfig(cfg);\n    SET_CONFIG = true;\n  };\n\n  /**\n   * Public method to remove the configuration\n   * clearConfig\n   *\n   */\n  DOMPurify.clearConfig = function() {\n    CONFIG = null;\n    SET_CONFIG = false;\n  };\n\n  /**\n   * Public method to check if an attribute value is valid.\n   * Uses last set config, if any. Otherwise, uses config defaults.\n   * isValidAttribute\n   *\n   * @param  {string} tag Tag name of containing element.\n   * @param  {string} attr Attribute name.\n   * @param  {string} value Attribute value.\n   * @return {Boolean} Returns true if `value` is valid. Otherwise, returns false.\n   */\n  DOMPurify.isValidAttribute = function(tag, attr, value) {\n    /* Initialize shared config vars if necessary. */\n    if (!CONFIG) {\n      _parseConfig({});\n    }\n\n    const lcTag = tag.toLowerCase();\n    const lcName = attr.toLowerCase();\n    return _isValidAttribute(lcTag, lcName, value);\n  };\n\n  /**\n   * AddHook\n   * Public method to add DOMPurify hooks\n   *\n   * @param {String} entryPoint entry point for the hook to add\n   * @param {Function} hookFunction function to execute\n   */\n  DOMPurify.addHook = function(entryPoint, hookFunction) {\n    if (typeof hookFunction !== 'function') {\n      return;\n    }\n\n    hooks[entryPoint] = hooks[entryPoint] || [];\n    hooks[entryPoint].push(hookFunction);\n  };\n\n  /**\n   * RemoveHook\n   * Public method to remove a DOMPurify hook at a given entryPoint\n   * (pops it from the stack of hooks if more are present)\n   *\n   * @param {String} entryPoint entry point for the hook to remove\n   */\n  DOMPurify.removeHook = function(entryPoint) {\n    if (hooks[entryPoint]) {\n      hooks[entryPoint].pop();\n    }\n  };\n\n  /**\n   * RemoveHooks\n   * Public method to remove all DOMPurify hooks at a given entryPoint\n   *\n   * @param  {String} entryPoint entry point for the hooks to remove\n   */\n  DOMPurify.removeHooks = function(entryPoint) {\n    if (hooks[entryPoint]) {\n      hooks[entryPoint] = [];\n    }\n  };\n\n  /**\n   * RemoveAllHooks\n   * Public method to remove all DOMPurify hooks\n   *\n   */\n  DOMPurify.removeAllHooks = function() {\n    hooks = {};\n  };\n\n  return DOMPurify;\n}\n\nexport default createDOMPurify();\n","const freeze =\n  Object.freeze ||\n  function(x) {\n    return x;\n  };\n\nexport const html = freeze([\n  'a',\n  'abbr',\n  'acronym',\n  'address',\n  'area',\n  'article',\n  'aside',\n  'audio',\n  'b',\n  'bdi',\n  'bdo',\n  'big',\n  'blink',\n  'blockquote',\n  'body',\n  'br',\n  'button',\n  'canvas',\n  'caption',\n  'center',\n  'cite',\n  'code',\n  'col',\n  'colgroup',\n  'content',\n  'data',\n  'datalist',\n  'dd',\n  'decorator',\n  'del',\n  'details',\n  'dfn',\n  'dir',\n  'div',\n  'dl',\n  'dt',\n  'element',\n  'em',\n  'fieldset',\n  'figcaption',\n  'figure',\n  'font',\n  'footer',\n  'form',\n  'h1',\n  'h2',\n  'h3',\n  'h4',\n  'h5',\n  'h6',\n  'head',\n  'header',\n  'hgroup',\n  'hr',\n  'html',\n  'i',\n  'img',\n  'input',\n  'ins',\n  'kbd',\n  'label',\n  'legend',\n  'li',\n  'main',\n  'map',\n  'mark',\n  'marquee',\n  'menu',\n  'menuitem',\n  'meter',\n  'nav',\n  'nobr',\n  'ol',\n  'optgroup',\n  'option',\n  'output',\n  'p',\n  'pre',\n  'progress',\n  'q',\n  'rp',\n  'rt',\n  'ruby',\n  's',\n  'samp',\n  'section',\n  'select',\n  'shadow',\n  'small',\n  'source',\n  'spacer',\n  'span',\n  'strike',\n  'strong',\n  'style',\n  'sub',\n  'summary',\n  'sup',\n  'table',\n  'tbody',\n  'td',\n  'template',\n  'textarea',\n  'tfoot',\n  'th',\n  'thead',\n  'time',\n  'tr',\n  'track',\n  'tt',\n  'u',\n  'ul',\n  'var',\n  'video',\n  'wbr',\n]);\n\n// SVG\nexport const svg = freeze([\n  'svg',\n  'a',\n  'altglyph',\n  'altglyphdef',\n  'altglyphitem',\n  'animatecolor',\n  'animatemotion',\n  'animatetransform',\n  'audio',\n  'canvas',\n  'circle',\n  'clippath',\n  'defs',\n  'desc',\n  'ellipse',\n  'filter',\n  'font',\n  'g',\n  'glyph',\n  'glyphref',\n  'hkern',\n  'image',\n  'line',\n  'lineargradient',\n  'marker',\n  'mask',\n  'metadata',\n  'mpath',\n  'path',\n  'pattern',\n  'polygon',\n  'polyline',\n  'radialgradient',\n  'rect',\n  'stop',\n  'style',\n  'switch',\n  'symbol',\n  'text',\n  'textpath',\n  'title',\n  'tref',\n  'tspan',\n  'video',\n  'view',\n  'vkern',\n]);\n\nexport const svgFilters = freeze([\n  'feBlend',\n  'feColorMatrix',\n  'feComponentTransfer',\n  'feComposite',\n  'feConvolveMatrix',\n  'feDiffuseLighting',\n  'feDisplacementMap',\n  'feDistantLight',\n  'feFlood',\n  'feFuncA',\n  'feFuncB',\n  'feFuncG',\n  'feFuncR',\n  'feGaussianBlur',\n  'feMerge',\n  'feMergeNode',\n  'feMorphology',\n  'feOffset',\n  'fePointLight',\n  'feSpecularLighting',\n  'feSpotLight',\n  'feTile',\n  'feTurbulence',\n]);\n\nexport const mathMl = freeze([\n  'math',\n  'menclose',\n  'merror',\n  'mfenced',\n  'mfrac',\n  'mglyph',\n  'mi',\n  'mlabeledtr',\n  'mmultiscripts',\n  'mn',\n  'mo',\n  'mover',\n  'mpadded',\n  'mphantom',\n  'mroot',\n  'mrow',\n  'ms',\n  'mspace',\n  'msqrt',\n  'mstyle',\n  'msub',\n  'msup',\n  'msubsup',\n  'mtable',\n  'mtd',\n  'mtext',\n  'mtr',\n  'munder',\n  'munderover',\n]);\n\nexport const text = freeze(['#text']);\n","const freeze =\n  Object.freeze ||\n  function(x) {\n    return x;\n  };\n\nexport const html = freeze([\n  'accept',\n  'action',\n  'align',\n  'alt',\n  'autocomplete',\n  'background',\n  'bgcolor',\n  'border',\n  'cellpadding',\n  'cellspacing',\n  'checked',\n  'cite',\n  'class',\n  'clear',\n  'color',\n  'cols',\n  'colspan',\n  'controls',\n  'coords',\n  'crossorigin',\n  'datetime',\n  'default',\n  'dir',\n  'disabled',\n  'download',\n  'enctype',\n  'face',\n  'for',\n  'headers',\n  'height',\n  'hidden',\n  'high',\n  'href',\n  'hreflang',\n  'id',\n  'integrity',\n  'ismap',\n  'label',\n  'lang',\n  'list',\n  'loop',\n  'low',\n  'max',\n  'maxlength',\n  'media',\n  'method',\n  'min',\n  'multiple',\n  'name',\n  'noshade',\n  'novalidate',\n  'nowrap',\n  'open',\n  'optimum',\n  'pattern',\n  'placeholder',\n  'poster',\n  'preload',\n  'pubdate',\n  'radiogroup',\n  'readonly',\n  'rel',\n  'required',\n  'rev',\n  'reversed',\n  'role',\n  'rows',\n  'rowspan',\n  'spellcheck',\n  'scope',\n  'selected',\n  'shape',\n  'size',\n  'sizes',\n  'span',\n  'srclang',\n  'start',\n  'src',\n  'srcset',\n  'step',\n  'style',\n  'summary',\n  'tabindex',\n  'title',\n  'type',\n  'usemap',\n  'valign',\n  'value',\n  'width',\n  'xmlns',\n]);\n\nexport const svg = freeze([\n  'accent-height',\n  'accumulate',\n  'additive',\n  'alignment-baseline',\n  'ascent',\n  'attributename',\n  'attributetype',\n  'azimuth',\n  'basefrequency',\n  'baseline-shift',\n  'begin',\n  'bias',\n  'by',\n  'class',\n  'clip',\n  'clip-path',\n  'clip-rule',\n  'color',\n  'color-interpolation',\n  'color-interpolation-filters',\n  'color-profile',\n  'color-rendering',\n  'cx',\n  'cy',\n  'd',\n  'dx',\n  'dy',\n  'diffuseconstant',\n  'direction',\n  'display',\n  'divisor',\n  'dur',\n  'edgemode',\n  'elevation',\n  'end',\n  'fill',\n  'fill-opacity',\n  'fill-rule',\n  'filter',\n  'filterunits',\n  'flood-color',\n  'flood-opacity',\n  'font-family',\n  'font-size',\n  'font-size-adjust',\n  'font-stretch',\n  'font-style',\n  'font-variant',\n  'font-weight',\n  'fx',\n  'fy',\n  'g1',\n  'g2',\n  'glyph-name',\n  'glyphref',\n  'gradientunits',\n  'gradienttransform',\n  'height',\n  'href',\n  'id',\n  'image-rendering',\n  'in',\n  'in2',\n  'k',\n  'k1',\n  'k2',\n  'k3',\n  'k4',\n  'kerning',\n  'keypoints',\n  'keysplines',\n  'keytimes',\n  'lang',\n  'lengthadjust',\n  'letter-spacing',\n  'kernelmatrix',\n  'kernelunitlength',\n  'lighting-color',\n  'local',\n  'marker-end',\n  'marker-mid',\n  'marker-start',\n  'markerheight',\n  'markerunits',\n  'markerwidth',\n  'maskcontentunits',\n  'maskunits',\n  'max',\n  'mask',\n  'media',\n  'method',\n  'mode',\n  'min',\n  'name',\n  'numoctaves',\n  'offset',\n  'operator',\n  'opacity',\n  'order',\n  'orient',\n  'orientation',\n  'origin',\n  'overflow',\n  'paint-order',\n  'path',\n  'pathlength',\n  'patterncontentunits',\n  'patterntransform',\n  'patternunits',\n  'points',\n  'preservealpha',\n  'preserveaspectratio',\n  'primitiveunits',\n  'r',\n  'rx',\n  'ry',\n  'radius',\n  'refx',\n  'refy',\n  'repeatcount',\n  'repeatdur',\n  'restart',\n  'result',\n  'rotate',\n  'scale',\n  'seed',\n  'shape-rendering',\n  'specularconstant',\n  'specularexponent',\n  'spreadmethod',\n  'stddeviation',\n  'stitchtiles',\n  'stop-color',\n  'stop-opacity',\n  'stroke-dasharray',\n  'stroke-dashoffset',\n  'stroke-linecap',\n  'stroke-linejoin',\n  'stroke-miterlimit',\n  'stroke-opacity',\n  'stroke',\n  'stroke-width',\n  'style',\n  'surfacescale',\n  'tabindex',\n  'targetx',\n  'targety',\n  'transform',\n  'text-anchor',\n  'text-decoration',\n  'text-rendering',\n  'textlength',\n  'type',\n  'u1',\n  'u2',\n  'unicode',\n  'values',\n  'viewbox',\n  'visibility',\n  'version',\n  'vert-adv-y',\n  'vert-origin-x',\n  'vert-origin-y',\n  'width',\n  'word-spacing',\n  'wrap',\n  'writing-mode',\n  'xchannelselector',\n  'ychannelselector',\n  'x',\n  'x1',\n  'x2',\n  'xmlns',\n  'y',\n  'y1',\n  'y2',\n  'z',\n  'zoomandpan',\n]);\n\nexport const mathMl = freeze([\n  'accent',\n  'accentunder',\n  'align',\n  'bevelled',\n  'close',\n  'columnsalign',\n  'columnlines',\n  'columnspan',\n  'denomalign',\n  'depth',\n  'dir',\n  'display',\n  'displaystyle',\n  'fence',\n  'frame',\n  'height',\n  'href',\n  'id',\n  'largeop',\n  'length',\n  'linethickness',\n  'lspace',\n  'lquote',\n  'mathbackground',\n  'mathcolor',\n  'mathsize',\n  'mathvariant',\n  'maxsize',\n  'minsize',\n  'movablelimits',\n  'notation',\n  'numalign',\n  'open',\n  'rowalign',\n  'rowlines',\n  'rowspacing',\n  'rowspan',\n  'rspace',\n  'rquote',\n  'scriptlevel',\n  'scriptminsize',\n  'scriptsizemultiplier',\n  'selection',\n  'separator',\n  'separators',\n  'stretchy',\n  'subscriptshift',\n  'supscriptshift',\n  'symmetric',\n  'voffset',\n  'width',\n  'xmlns',\n]);\n\nexport const xml = freeze([\n  'xlink:href',\n  'xml:id',\n  'xlink:title',\n  'xml:space',\n  'xmlns:xlink',\n]);\n","const { hasOwnProperty, setPrototypeOf } = Object;\nlet { apply } = typeof Reflect !== 'undefined' && Reflect;\n\nif (!apply) {\n  apply = function(fun, thisValue, args) {\n    return fun.apply(thisValue, args);\n  };\n}\n\n/* Add properties to a lookup table */\nexport function addToSet(set, array) {\n  if (setPrototypeOf) {\n    // Make 'in' and truthy checks like Boolean(set.constructor)\n    // independent of any properties defined on Object.prototype.\n    // Prevent prototype setters from intercepting set as a this value.\n    setPrototypeOf(set, null);\n  }\n\n  let l = array.length;\n  while (l--) {\n    let element = array[l];\n    if (typeof element === 'string') {\n      const lcElement = element.toLowerCase();\n      if (lcElement !== element) {\n        // Config presets (e.g. tags.js, attrs.js) are immutable.\n        if (!Object.isFrozen(array)) {\n          array[l] = lcElement;\n        }\n\n        element = lcElement;\n      }\n    }\n\n    set[element] = true;\n  }\n\n  return set;\n}\n\n/* Shallow clone an object */\nexport function clone(object) {\n  const newObject = {};\n\n  let property;\n  for (property in object) {\n    if (apply(hasOwnProperty, object, [property])) {\n      newObject[property] = object[property];\n    }\n  }\n\n  return newObject;\n}\n","const seal =\n  Object.seal ||\n  function(x) {\n    return x;\n  };\n\nexport const MUSTACHE_EXPR = seal(/\\{\\{[\\s\\S]*|[\\s\\S]*\\}\\}/gm); // Specify template detection regex for SAFE_FOR_TEMPLATES mode\nexport const ERB_EXPR = seal(/<%[\\s\\S]*|[\\s\\S]*%>/gm);\nexport const DATA_ATTR = seal(/^data-[\\-\\w.\\u00B7-\\uFFFF]/); // eslint-disable-line no-useless-escape\nexport const ARIA_ATTR = seal(/^aria-[\\-\\w]+$/); // eslint-disable-line no-useless-escape\nexport const IS_ALLOWED_URI = seal(\n  /^(?:(?:(?:f|ht)tps?|mailto|tel|callto|cid|xmpp):|[^a-z]|[a-z+.\\-]+(?:[^a-z+.\\-:]|$))/i // eslint-disable-line no-useless-escape\n);\nexport const IS_SCRIPT_OR_DATA = seal(/^(?:\\w+script|data):/i);\nexport const ATTR_WHITESPACE = seal(\n  /[\\u0000-\\u0020\\u00A0\\u1680\\u180E\\u2000-\\u2029\\u205f\\u3000]/g // eslint-disable-line no-control-regex\n);\n","import DOMPurify from 'dompurify'\r\n\r\nexport const select = (selector, element) => {\r\n  return (element || document).querySelector(selector)\r\n}\r\n\r\nexport const sanitize = (string) => {\r\n  return DOMPurify.sanitize(string, { ALLOWED_TAGS: ['strong', 'em'] })\r\n}","export const createTodoItemContent = (id, name, completed) => {\r\n  return (\r\n    `<div class=\"item-content\">\r\n      <div>\r\n        <div class=\"handle hidden\">\r\n          <i class=\"fas fa-grip-vertical\"></i>\r\n        </div>\r\n      </div>\r\n\r\n      <div class=\"toggle\" data-id=\"${id}\">\r\n        <label>\r\n          <input type=\"checkbox\" data-id=\"${id}\" ${completed ? 'checked' : ''}>\r\n          <div class=\"check-mark\" data-id=\"${id}\"></div>\r\n        </label>\r\n      </div>\r\n\r\n      <div class=\"todo-content\" data-id=\"${id}\">${name}</div>\r\n      \r\n      <input type=\"text\" class=\"edit hidden\" data-id=\"${id}\">\r\n      \r\n      <div>\r\n        <button class=\"del-btn hidden\" data-id=\"${id}\">\r\n          <i class=\"fas fa-trash\"></i>\r\n        </button>\r\n      </div>\r\n    </div>`\r\n  )\r\n}","import { select } from '../utils/helpers'\r\nimport { createTodoItemContent } from '../templates/todoItem'\r\n\r\nexport default class View {\r\n  constructor(grid, list, input) {\r\n    this.grid = grid\r\n    this.list = list\r\n    this.input = input\r\n  }\r\n\r\n  addItemToGrid({ id, name, completed }, handlers) {\r\n    const itemDiv = document.createElement('div')\r\n    const itemContentDiv = createTodoItemContent(id, name, completed)\r\n\r\n    itemDiv.classList.add('item')\r\n    itemDiv.dataset.id = id\r\n    itemDiv.innerHTML = itemContentDiv\r\n\r\n    this.updateItemStyling(itemDiv, completed)\r\n    this.addEventListenersForTodoItem(itemDiv, handlers)\r\n    this.grid.add(itemDiv)\r\n  }\r\n\r\n  removeItemFromGrid(id, handlers) {\r\n    const item = select(`.item[data-id=\"${id}\"]`)\r\n\r\n    this.removeEventListenersFromTodoItem(item, handlers)\r\n    this.grid.remove(item, { removeElements: true })\r\n  }\r\n\r\n  updateItemName(id, newName) {\r\n    select(`.todo-content[data-id=\"${id}\"]`, this.list).innerHTML = newName\r\n  }\r\n\r\n  updateItemStyling(item, isCompleted) {\r\n    const content = select('.todo-content', item)\r\n    \r\n    isCompleted ? content.classList.add('completed') : content.classList.remove('completed')\r\n  }\r\n\r\n  updateItemIndices() {\r\n    const items = this.grid.getItems()\r\n    \r\n    items.forEach((item, i) => item.getElement().dataset.index = i)\r\n  }\r\n\r\n  selectItemElements(item) {\r\n    return {\r\n      toggle: select('input[type=\"checkbox\"]', item),\r\n      todoContent: select('.todo-content', item),\r\n      deleteButton: select('.del-btn', item),\r\n      editInput: select('.edit', item)\r\n    }\r\n  }\r\n\r\n  addEventListenersForTodoItem(item, handlers) {\r\n    const { toggle, todoContent, deleteButton, editInput } = this.selectItemElements(item)\r\n\r\n    toggle.addEventListener('click', handlers.handleToggleClick)\r\n    todoContent.addEventListener('dblclick', handlers.handleTodoContentDoubleClick)\r\n    deleteButton.addEventListener('click', handlers.handleDeleteButtonClick) \r\n    editInput.addEventListener('blur', handlers.handleEditInputBlur)\r\n    editInput.addEventListener('keyup', handlers.handleEditInputKeyup)\r\n  }\r\n\r\n  removeEventListenersFromTodoItem(item, handlers) {\r\n    const { toggle, todoContent, deleteButton, editInput } = this.selectItemElements(item)\r\n\r\n    toggle.removeEventListener('click', handlers.handleToggleClick)\r\n    todoContent.removeEventListener('dblclick', handlers.handleTodoContentDoubleClick)\r\n    deleteButton.removeEventListener('click', handlers.handleDeleteButtonClick)\r\n    editInput.removeEventListener('blur', handlers.handleEditInputBlur)\r\n    editInput.removeEventListener('keyup', handlers.handleEditInputKeyup)\r\n  }\r\n}","/**\n* Muuri v0.8.0\n* https://github.com/haltu/muuri\n* Copyright (c) 2015-present, Haltu Oy\n* Released under the MIT license\n* https://github.com/haltu/muuri/blob/master/LICENSE.md\n* @license MIT\n*\n* Muuri Packer\n* Copyright (c) 2016-present, Niklas Rämö <inramo@gmail.com>\n* @license MIT\n*\n* Muuri Ticker / Muuri Emitter / Muuri Queue\n* Copyright (c) 2018-present, Niklas Rämö <inramo@gmail.com>\n* @license MIT\n*/\n\n(function (global, factory) {\n  typeof exports === 'object' && typeof module !== 'undefined' ? module.exports = factory() :\n  typeof define === 'function' && define.amd ? define(factory) :\n  (global = global || self, global.Muuri = factory());\n}(this, function () { 'use strict';\n\n  var namespace = 'Muuri';\n  var gridInstances = {};\n\n  var actionSwap = 'swap';\n  var actionMove = 'move';\n\n  var eventSynchronize = 'synchronize';\n  var eventLayoutStart = 'layoutStart';\n  var eventLayoutEnd = 'layoutEnd';\n  var eventAdd = 'add';\n  var eventRemove = 'remove';\n  var eventShowStart = 'showStart';\n  var eventShowEnd = 'showEnd';\n  var eventHideStart = 'hideStart';\n  var eventHideEnd = 'hideEnd';\n  var eventFilter = 'filter';\n  var eventSort = 'sort';\n  var eventMove = 'move';\n  var eventSend = 'send';\n  var eventBeforeSend = 'beforeSend';\n  var eventReceive = 'receive';\n  var eventBeforeReceive = 'beforeReceive';\n  var eventDragInit = 'dragInit';\n  var eventDragStart = 'dragStart';\n  var eventDragMove = 'dragMove';\n  var eventDragScroll = 'dragScroll';\n  var eventDragEnd = 'dragEnd';\n  var eventDragReleaseStart = 'dragReleaseStart';\n  var eventDragReleaseEnd = 'dragReleaseEnd';\n  var eventDestroy = 'destroy';\n\n  /**\n   * Event emitter constructor.\n   *\n   * @class\n   */\n  function Emitter() {\n    this._events = {};\n    this._queue = [];\n    this._counter = 0;\n    this._isDestroyed = false;\n  }\n\n  /**\n   * Public prototype methods\n   * ************************\n   */\n\n  /**\n   * Bind an event listener.\n   *\n   * @public\n   * @memberof Emitter.prototype\n   * @param {String} event\n   * @param {Function} listener\n   * @returns {Emitter}\n   */\n  Emitter.prototype.on = function(event, listener) {\n    if (this._isDestroyed) return this;\n\n    // Get listeners queue and create it if it does not exist.\n    var listeners = this._events[event];\n    if (!listeners) listeners = this._events[event] = [];\n\n    // Add the listener to the queue.\n    listeners.push(listener);\n\n    return this;\n  };\n\n  /**\n   * Unbind all event listeners that match the provided listener function.\n   *\n   * @public\n   * @memberof Emitter.prototype\n   * @param {String} event\n   * @param {Function} [listener]\n   * @returns {Emitter}\n   */\n  Emitter.prototype.off = function(event, listener) {\n    if (this._isDestroyed) return this;\n\n    // Get listeners and return immediately if none is found.\n    var listeners = this._events[event];\n    if (!listeners || !listeners.length) return this;\n\n    // If no specific listener is provided remove all listeners.\n    if (!listener) {\n      listeners.length = 0;\n      return this;\n    }\n\n    // Remove all matching listeners.\n    var i = listeners.length;\n    while (i--) {\n      if (listener === listeners[i]) listeners.splice(i, 1);\n    }\n\n    return this;\n  };\n\n  /**\n   * Emit all listeners in a specified event with the provided arguments.\n   *\n   * @public\n   * @memberof Emitter.prototype\n   * @param {String} event\n   * @param {*} [arg1]\n   * @param {*} [arg2]\n   * @param {*} [arg3]\n   * @returns {Emitter}\n   */\n  Emitter.prototype.emit = function(event, arg1, arg2, arg3) {\n    if (this._isDestroyed) return this;\n\n    // Get event listeners and quit early if there's no listeners.\n    var listeners = this._events[event];\n    if (!listeners || !listeners.length) return this;\n\n    var queue = this._queue;\n    var qLength = queue.length;\n    var aLength = arguments.length - 1;\n    var i;\n\n    // Add the current listeners to the callback queue before we process them.\n    // This is necessary to guarantee that all of the listeners are called in\n    // correct order even if new event listeners are removed/added during\n    // processing and/or events are emitted during processing.\n    for (i = 0; i < listeners.length; i++) {\n      queue.push(listeners[i]);\n    }\n\n    // Increment queue counter. This is needed for the scenarios where emit is\n    // triggered while the queue is already processing. We need to keep track of\n    // how many \"queue processors\" there are active so that we can safely reset\n    // the queue in the end when the last queue processor is finished.\n    ++this._counter;\n\n    // Process the queue (the specific part of it for this emit).\n    for (i = qLength, qLength = queue.length; i < qLength; i++) {\n      // prettier-ignore\n      aLength === 0 ? queue[i]() :\n      aLength === 1 ? queue[i](arg1) :\n      aLength === 2 ? queue[i](arg1, arg2) :\n                      queue[i](arg1, arg2, arg3);\n\n      // Stop processing if the emitter is destroyed.\n      if (this._isDestroyed) return this;\n    }\n\n    // Decrement queue process counter.\n    --this._counter;\n\n    // Reset the queue if there are no more queue processes running.\n    if (!this._counter) queue.length = 0;\n\n    return this;\n  };\n\n  /**\n   * Destroy emitter instance. Basically just removes all bound listeners.\n   *\n   * @public\n   * @memberof Emitter.prototype\n   * @returns {Emitter}\n   */\n  Emitter.prototype.destroy = function() {\n    if (this._isDestroyed) return this;\n\n    var events = this._events;\n    var event;\n\n    // Flag as destroyed.\n    this._isDestroyed = true;\n\n    // Reset queue (if queue is currently processing this will also stop that).\n    this._queue.length = this._counter = 0;\n\n    // Remove all listeners.\n    for (event in events) {\n      if (events[event]) {\n        events[event].length = 0;\n        events[event] = undefined;\n      }\n    }\n\n    return this;\n  };\n\n  // Set up the default export values.\n  var transformStyle = 'transform';\n  var transformProp = 'transform';\n\n  // Find the supported transform prop and style names.\n  var docElemStyle = window.document.documentElement.style;\n  var style = 'transform';\n  var styleCap = 'Transform';\n  var found = false;\n  ['', 'Webkit', 'Moz', 'O', 'ms'].forEach(function(prefix) {\n    if (found) return;\n    var propName = prefix ? prefix + styleCap : style;\n    if (docElemStyle[propName] !== undefined) {\n      prefix = prefix.toLowerCase();\n      transformStyle = prefix ? '-' + prefix + '-' + style : style;\n      transformProp = propName;\n      found = true;\n    }\n  });\n\n  var stylesCache = typeof WeakMap === 'function' ? new WeakMap() : null;\n\n  /**\n   * Returns the computed value of an element's style property as a string.\n   *\n   * @param {HTMLElement} element\n   * @param {String} style\n   * @returns {String}\n   */\n  function getStyle(element, style) {\n    var styles = stylesCache && stylesCache.get(element);\n    if (!styles) {\n      styles = window.getComputedStyle(element, null);\n      if (stylesCache) stylesCache.set(element, styles);\n    }\n    return styles.getPropertyValue(style === 'transform' ? transformStyle : style);\n  }\n\n  var styleNameRegEx = /([A-Z])/g;\n\n  /**\n   * Transforms a camel case style property to kebab case style property.\n   *\n   * @param {String} string\n   * @returns {String}\n   */\n  function getStyleName(string) {\n    return string.replace(styleNameRegEx, '-$1').toLowerCase();\n  }\n\n  var strFunction = 'function';\n\n  /**\n   * Check if a value is a function.\n   *\n   * @param {*} val\n   * @returns {Boolean}\n   */\n  function isFunction(val) {\n    return typeof val === strFunction;\n  }\n\n  var transformStyle$1 = 'transform';\n\n  /**\n   * Set inline styles to an element.\n   *\n   * @param {HTMLElement} element\n   * @param {Object} styles\n   */\n  function setStyles(element, styles) {\n    for (var prop in styles) {\n      element.style[prop === transformStyle$1 ? transformProp : prop] = styles[prop];\n    }\n  }\n\n  /**\n   * Item animation handler powered by Web Animations API.\n   *\n   * @class\n   * @param {HTMLElement} element\n   */\n  function ItemAnimate(element) {\n    this._element = element;\n    this._animation = null;\n    this._callback = null;\n    this._props = [];\n    this._values = [];\n    this._keyframes = [];\n    this._options = {};\n    this._isDestroyed = false;\n    this._onFinish = this._onFinish.bind(this);\n  }\n\n  /**\n   * Public prototype methods\n   * ************************\n   */\n\n  /**\n   * Start instance's animation. Automatically stops current animation if it is\n   * running.\n   *\n   * @public\n   * @memberof ItemAnimate.prototype\n   * @param {Object} propsFrom\n   * @param {Object} propsTo\n   * @param {Object} [options]\n   * @param {Number} [options.duration=300]\n   * @param {String} [options.easing='ease']\n   * @param {Function} [options.onFinish]\n   */\n  ItemAnimate.prototype.start = function(propsFrom, propsTo, options) {\n    if (this._isDestroyed) return;\n\n    var animation = this._animation;\n    var currentProps = this._props;\n    var currentValues = this._values;\n    var opts = options || 0;\n    var cancelAnimation = false;\n\n    // If we have an existing animation running, let's check if it needs to be\n    // cancelled or if it can continue running.\n    if (animation) {\n      var propCount = 0;\n      var propIndex;\n\n      // Check if the requested animation target props and values match with the\n      // current props and values.\n      for (var propName in propsTo) {\n        ++propCount;\n        propIndex = currentProps.indexOf(propName);\n        if (propIndex === -1 || propsTo[propName] !== currentValues[propIndex]) {\n          cancelAnimation = true;\n          break;\n        }\n      }\n\n      // Check if the target props count matches current props count. This is\n      // needed for the edge case scenario where target props contain the same\n      // styles as current props, but the current props have some additional\n      // props.\n      if (!cancelAnimation && propCount !== currentProps.length) {\n        cancelAnimation = true;\n      }\n    }\n\n    // Cancel animation (if required).\n    if (cancelAnimation) animation.cancel();\n\n    // Store animation callback.\n    this._callback = isFunction(opts.onFinish) ? opts.onFinish : null;\n\n    // If we have a running animation that does not need to be cancelled, let's\n    // call it a day here and let it run.\n    if (animation && !cancelAnimation) return;\n\n    // Store target props and values to instance.\n    currentProps.length = currentValues.length = 0;\n    for (propName in propsTo) {\n      currentProps.push(propName);\n      currentValues.push(propsTo[propName]);\n    }\n\n    // Set up keyframes.\n    var animKeyframes = this._keyframes;\n    animKeyframes[0] = propsFrom;\n    animKeyframes[1] = propsTo;\n\n    // Set up options.\n    var animOptions = this._options;\n    animOptions.duration = opts.duration || 300;\n    animOptions.easing = opts.easing || 'ease';\n\n    // Start the animation\n    var element = this._element;\n    animation = element.animate(animKeyframes, animOptions);\n    animation.onfinish = this._onFinish;\n    this._animation = animation;\n\n    // Set the end styles. This makes sure that the element stays at the end\n    // values after animation is finished.\n    setStyles(element, propsTo);\n  };\n\n  /**\n   * Stop instance's current animation if running.\n   *\n   * @public\n   * @memberof ItemAnimate.prototype\n   * @param {Object} [styles]\n   */\n  ItemAnimate.prototype.stop = function(styles) {\n    if (this._isDestroyed || !this._animation) return;\n\n    var element = this._element;\n    var currentProps = this._props;\n    var currentValues = this._values;\n    var propName;\n    var propValue;\n    var i;\n\n    // Calculate (if not provided) and set styles.\n    if (!styles) {\n      for (i = 0; i < currentProps.length; i++) {\n        propName = currentProps[i];\n        propValue = getStyle(element, getStyleName(propName));\n        element.style[propName === 'transform' ? transformProp : propName] = propValue;\n      }\n    } else {\n      setStyles(element, styles);\n    }\n\n    //  Cancel animation.\n    this._animation.cancel();\n    this._animation = this._callback = null;\n\n    // Reset current props and values.\n    currentProps.length = currentValues.length = 0;\n  };\n\n  /**\n   * Check if the item is being animated currently.\n   *\n   * @public\n   * @memberof ItemAnimate.prototype\n   * @return {Boolean}\n   */\n  ItemAnimate.prototype.isAnimating = function() {\n    return !!this._animation;\n  };\n\n  /**\n   * Destroy the instance and stop current animation if it is running.\n   *\n   * @public\n   * @memberof ItemAnimate.prototype\n   */\n  ItemAnimate.prototype.destroy = function() {\n    if (this._isDestroyed) return;\n    this.stop();\n    this._element = this._options = this._keyframes = null;\n    this._isDestroyed = true;\n  };\n\n  /**\n   * Private prototype methods\n   * *************************\n   */\n\n  /**\n   * Animation end handler.\n   *\n   * @private\n   * @memberof ItemAnimate.prototype\n   */\n  ItemAnimate.prototype._onFinish = function() {\n    var callback = this._callback;\n    this._animation = this._callback = null;\n    this._props.length = this._values.length = 0;\n    callback && callback();\n  };\n\n  var vendorPrefixes = ['', 'webkit', 'moz', 'ms', 'o', 'Webkit', 'Moz', 'MS', 'O'];\n\n  /**\n   * Get prefixed CSS property name when given a non-prefixed CSS property name.\n   * @param {Object} elemStyle\n   * @param {String} propName\n   * @returns {!String}\n   */\n  function getPrefixedPropName(elemStyle, propName) {\n    var camelPropName = propName[0].toUpperCase() + propName.slice(1);\n    var i = 0;\n    var prefix;\n    var prefixedPropName;\n\n    while (i < vendorPrefixes.length) {\n      prefix = vendorPrefixes[i];\n      prefixedPropName = prefix ? prefix + camelPropName : propName;\n      if (prefixedPropName in elemStyle) return prefixedPropName;\n      ++i;\n    }\n\n    return null;\n  }\n\n  var dt = 1000 / 60;\n\n  var raf = (\n    window.requestAnimationFrame ||\n    window.webkitRequestAnimationFrame ||\n    window.mozRequestAnimationFrame ||\n    window.msRequestAnimationFrame ||\n    function(callback) {\n      return this.setTimeout(function() {\n        callback(dt);\n      }, dt);\n    }\n  ).bind(window);\n\n  // Detect support for passive events:\n  // https://github.com/WICG/EventListenerOptions/blob/gh-pages/explainer.md#feature-detection\n  var isPassiveEventsSupported = false;\n  try {\n    var passiveOpts = Object.defineProperty({}, 'passive', {\n      get: function() {\n        isPassiveEventsSupported = true;\n      }\n    });\n    window.addEventListener('testPassive', null, passiveOpts);\n    window.removeEventListener('testPassive', null, passiveOpts);\n  } catch (e) {}\n\n  // Dragger events.\n  var events = {\n    start: 'start',\n    move: 'move',\n    end: 'end',\n    cancel: 'cancel'\n  };\n\n  var hasTouchEvents = !!('ontouchstart' in window || window.TouchEvent);\n  var hasPointerEvents = !!window.PointerEvent;\n  var hasMsPointerEvents = !!window.navigator.msPointerEnabled;\n  var isAndroid = /(android)/i.test(window.navigator.userAgent);\n  var listenerOptions = isPassiveEventsSupported ? { passive: true } : false;\n\n  var taProp = 'touchAction';\n  var taPropPrefixed = getPrefixedPropName(window.document.documentElement.style, taProp);\n  var taDefaultValue = 'auto';\n\n  /**\n   * Creates a new Dragger instance for an element.\n   *\n   * @public\n   * @class\n   * @param {HTMLElement} element\n   * @param {Object} [cssProps]\n   */\n  function Dragger(element, cssProps) {\n    this._element = element;\n    this._emitter = new Emitter();\n    this._isDestroyed = false;\n    this._cssProps = {};\n    this._touchAction = '';\n    this._startEvent = null;\n\n    this._pointerId = null;\n    this._startTime = 0;\n    this._startX = 0;\n    this._startY = 0;\n    this._currentX = 0;\n    this._currentY = 0;\n\n    this._preStartCheck = this._preStartCheck.bind(this);\n    this._abortNonCancelable = this._abortNonCancelable.bind(this);\n    this._onStart = this._onStart.bind(this);\n    this._onMove = this._onMove.bind(this);\n    this._onCancel = this._onCancel.bind(this);\n    this._onEnd = this._onEnd.bind(this);\n\n    // Apply initial css props.\n    this.setCssProps(cssProps);\n\n    // If touch action was not provided with initial css props let's assume it's\n    // auto.\n    if (!this._touchAction) {\n      this.setTouchAction(taDefaultValue);\n    }\n\n    // Prevent native link/image dragging for the item and it's ancestors.\n    element.addEventListener('dragstart', Dragger._preventDefault, false);\n\n    // Listen to start event.\n    element.addEventListener(Dragger._events.start, this._preStartCheck, listenerOptions);\n\n    // If we have touch events, but no pointer events we need to also listen for\n    // mouse events in addition to touch events for devices which support both\n    // mouse and touch interaction.\n    if (hasTouchEvents && !hasPointerEvents && !hasMsPointerEvents) {\n      element.addEventListener(Dragger._mouseEvents.start, this._preStartCheck, listenerOptions);\n    }\n  }\n\n  /**\n   * Protected properties\n   * ********************\n   */\n\n  Dragger._pointerEvents = {\n    start: 'pointerdown',\n    move: 'pointermove',\n    cancel: 'pointercancel',\n    end: 'pointerup'\n  };\n\n  Dragger._msPointerEvents = {\n    start: 'MSPointerDown',\n    move: 'MSPointerMove',\n    cancel: 'MSPointerCancel',\n    end: 'MSPointerUp'\n  };\n\n  Dragger._touchEvents = {\n    start: 'touchstart',\n    move: 'touchmove',\n    cancel: 'touchcancel',\n    end: 'touchend'\n  };\n\n  Dragger._mouseEvents = {\n    start: 'mousedown',\n    move: 'mousemove',\n    cancel: '',\n    end: 'mouseup'\n  };\n\n  Dragger._events = (function() {\n    if (hasPointerEvents) return Dragger._pointerEvents;\n    if (hasMsPointerEvents) return Dragger._msPointerEvents;\n    if (hasTouchEvents) return Dragger._touchEvents;\n    return Dragger._mouseEvents;\n  })();\n\n  Dragger._emitter = new Emitter();\n\n  Dragger._activeInstances = [];\n\n  /**\n   * Protected static methods\n   * ************************\n   */\n\n  Dragger._preventDefault = function(e) {\n    if (e.preventDefault && e.cancelable !== false) e.preventDefault();\n  };\n\n  Dragger._activateInstance = function(instance) {\n    var index = Dragger._activeInstances.indexOf(instance);\n    if (index > -1) return;\n\n    Dragger._activeInstances.push(instance);\n    Dragger._emitter.on(events.move, instance._onMove);\n    Dragger._emitter.on(events.cancel, instance._onCancel);\n    Dragger._emitter.on(events.end, instance._onEnd);\n\n    if (Dragger._activeInstances.length === 1) {\n      Dragger._bindListeners();\n    }\n  };\n\n  Dragger._deactivateInstance = function(instance) {\n    var index = Dragger._activeInstances.indexOf(instance);\n    if (index === -1) return;\n\n    Dragger._activeInstances.splice(index, 1);\n    Dragger._emitter.off(events.move, instance._onMove);\n    Dragger._emitter.off(events.cancel, instance._onCancel);\n    Dragger._emitter.off(events.end, instance._onEnd);\n\n    if (!Dragger._activeInstances.length) {\n      Dragger._unbindListeners();\n    }\n  };\n\n  Dragger._bindListeners = function() {\n    var events = Dragger._events;\n    window.addEventListener(events.move, Dragger._onMove, listenerOptions);\n    window.addEventListener(events.end, Dragger._onEnd, listenerOptions);\n    events.cancel && window.addEventListener(events.cancel, Dragger._onCancel, listenerOptions);\n  };\n\n  Dragger._unbindListeners = function() {\n    var events = Dragger._events;\n    window.removeEventListener(events.move, Dragger._onMove, listenerOptions);\n    window.removeEventListener(events.end, Dragger._onEnd, listenerOptions);\n    events.cancel && window.removeEventListener(events.cancel, Dragger._onCancel, listenerOptions);\n  };\n\n  Dragger._getEventPointerId = function(event) {\n    // If we have pointer id available let's use it.\n    if (typeof event.pointerId === 'number') {\n      return event.pointerId;\n    }\n\n    // For touch events let's get the first changed touch's identifier.\n    if (event.changedTouches) {\n      return event.changedTouches[0] ? event.changedTouches[0].identifier : null;\n    }\n\n    // For mouse/other events let's provide a static id.\n    return 1;\n  };\n\n  Dragger._getTouchById = function(event, id) {\n    // If we have a pointer event return the whole event if there's a match, and\n    // null otherwise.\n    if (typeof event.pointerId === 'number') {\n      return event.pointerId === id ? event : null;\n    }\n\n    // For touch events let's check if there's a changed touch object that matches\n    // the pointerId in which case return the touch object.\n    if (event.changedTouches) {\n      for (var i = 0; i < event.changedTouches.length; i++) {\n        if (event.changedTouches[i].identifier === id) {\n          return event.changedTouches[i];\n        }\n      }\n      return null;\n    }\n\n    // For mouse/other events let's assume there's only one pointer and just\n    // return the event.\n    return event;\n  };\n\n  Dragger._onMove = function(e) {\n    Dragger._emitter.emit(events.move, e);\n  };\n\n  Dragger._onCancel = function(e) {\n    Dragger._emitter.emit(events.cancel, e);\n  };\n\n  Dragger._onEnd = function(e) {\n    Dragger._emitter.emit(events.end, e);\n  };\n\n  /**\n   * Private prototype methods\n   * *************************\n   */\n\n  /**\n   * Reset current drag operation (if any).\n   *\n   * @private\n   * @memberof Dragger.prototype\n   */\n  Dragger.prototype._reset = function() {\n    if (this._isDestroyed) return;\n\n    this._pointerId = null;\n    this._startTime = 0;\n    this._startX = 0;\n    this._startY = 0;\n    this._currentX = 0;\n    this._currentY = 0;\n    this._startEvent = null;\n\n    this._element.removeEventListener(\n      Dragger._touchEvents.start,\n      this._abortNonCancelable,\n      listenerOptions\n    );\n\n    Dragger._deactivateInstance(this);\n  };\n\n  /**\n   * Create a custom dragger event from a raw event.\n   *\n   * @private\n   * @memberof Dragger.prototype\n   * @param {String} type\n   * @param {(PointerEvent|TouchEvent|MouseEvent)} e\n   * @returns {DraggerEvent}\n   */\n  Dragger.prototype._createEvent = function(type, e) {\n    var touch = this._getTrackedTouch(e);\n    return {\n      // Hammer.js compatibility interface.\n      type: type,\n      srcEvent: e,\n      distance: this.getDistance(),\n      deltaX: this.getDeltaX(),\n      deltaY: this.getDeltaY(),\n      deltaTime: type === events.start ? 0 : this.getDeltaTime(),\n      isFirst: type === events.start,\n      isFinal: type === events.end || type === events.cancel,\n      // Partial Touch API interface.\n      identifier: this._pointerId,\n      screenX: touch.screenX,\n      screenY: touch.screenY,\n      clientX: touch.clientX,\n      clientY: touch.clientY,\n      pageX: touch.pageX,\n      pageY: touch.pageY,\n      target: touch.target\n    };\n  };\n\n  /**\n   * Emit a raw event as dragger event internally.\n   *\n   * @private\n   * @memberof Dragger.prototype\n   * @param {String} type\n   * @param {(PointerEvent|TouchEvent|MouseEvent)} e\n   */\n  Dragger.prototype._emit = function(type, e) {\n    this._emitter.emit(type, this._createEvent(type, e));\n  };\n\n  /**\n   * If the provided event is a PointerEvent this method will return it if it has\n   * the same pointerId as the instance. If the provided event is a TouchEvent\n   * this method will try to look for a Touch instance in the changedTouches that\n   * has an identifier matching this instance's pointerId. If the provided event\n   * is a MouseEvent (or just any other event than PointerEvent or TouchEvent)\n   * it will be returned immediately.\n   *\n   * @private\n   * @memberof Dragger.prototype\n   * @param {(PointerEvent|TouchEvent|MouseEvent)}\n   * @returns {?(Touch|PointerEvent|MouseEvent)}\n   */\n  Dragger.prototype._getTrackedTouch = function(e) {\n    if (this._pointerId === null) {\n      return null;\n    } else {\n      return Dragger._getTouchById(e, this._pointerId);\n    }\n  };\n\n  /**\n   * A pre-handler for start event that checks if we can start dragging.\n   *\n   * @private\n   * @memberof Dragger.prototype\n   * @param {(PointerEvent|TouchEvent|MouseEvent)} e\n   */\n  Dragger.prototype._preStartCheck = function(e) {\n    if (this._isDestroyed) return;\n\n    // Make sure the element is not being dragged currently.\n    if (this.isDragging()) return;\n\n    // Special cancelable check for Android to prevent drag procedure from\n    // starting if native scrolling is in progress. Part 1.\n    if (isAndroid && e.cancelable === false) return;\n\n    // Make sure left button is pressed on mouse.\n    if (e.button) return;\n\n    // Get (and set) pointer id.\n    this._pointerId = Dragger._getEventPointerId(e);\n    if (this._pointerId === null) return;\n\n    // Store the start event and trigger start (async or sync). Pointer events\n    // are emitted before touch events if the browser supports both of them. And\n    // if you try to move an element before `touchstart` is emitted the pointer\n    // events for that element will be canceled. The fix is to delay the emitted\n    // pointer events in such a scenario by one frame so that `touchstart` has\n    // time to be emitted before the element is (potentially) moved.\n    this._startEvent = e;\n    if (hasTouchEvents && (hasPointerEvents || hasMsPointerEvents)) {\n      // Special cancelable check for Android to prevent drag procedure from\n      // starting if native scrolling is in progress. Part 2.\n      if (isAndroid) {\n        this._element.addEventListener(\n          Dragger._touchEvents.start,\n          this._abortNonCancelable,\n          listenerOptions\n        );\n      }\n      raf(this._onStart);\n    } else {\n      this._onStart();\n    }\n  };\n\n  /**\n   * Abort start event if it turns out to be non-cancelable.\n   *\n   * @private\n   * @memberof Dragger.prototype\n   * @param {(PointerEvent|TouchEvent|MouseEvent)} e\n   */\n  Dragger.prototype._abortNonCancelable = function(e) {\n    this._element.removeEventListener(\n      Dragger._touchEvents.start,\n      this._abortNonCancelable,\n      listenerOptions\n    );\n\n    if (this._startEvent && e.cancelable === false) {\n      this._pointerId = null;\n      this._startEvent = null;\n    }\n  };\n\n  /**\n   * Start the drag procedure if possible.\n   *\n   * @private\n   * @memberof Dragger.prototype\n   */\n  Dragger.prototype._onStart = function() {\n    var e = this._startEvent;\n    if (!e) return;\n\n    this._startEvent = null;\n\n    var touch = this._getTrackedTouch(e);\n    if (!touch) return;\n\n    // Set up init data and emit start event.\n    this._startX = this._currentX = touch.clientX;\n    this._startY = this._currentY = touch.clientY;\n    this._startTime = Date.now();\n    this._emit(events.start, e);\n    Dragger._activateInstance(this);\n  };\n\n  /**\n   * Handler for move event.\n   *\n   * @private\n   * @memberof Dragger.prototype\n   * @param {(PointerEvent|TouchEvent|MouseEvent)} e\n   */\n  Dragger.prototype._onMove = function(e) {\n    var touch = this._getTrackedTouch(e);\n    if (!touch) return;\n\n    this._currentX = touch.clientX;\n    this._currentY = touch.clientY;\n    this._emit(events.move, e);\n  };\n\n  /**\n   * Handler for move cancel event.\n   *\n   * @private\n   * @memberof Dragger.prototype\n   * @param {(PointerEvent|TouchEvent|MouseEvent)} e\n   */\n  Dragger.prototype._onCancel = function(e) {\n    if (!this._getTrackedTouch(e)) return;\n\n    this._emit(events.cancel, e);\n    this._reset();\n  };\n\n  /**\n   * Handler for end event.\n   *\n   * @private\n   * @memberof Dragger.prototype\n   * @param {(PointerEvent|TouchEvent|MouseEvent)} e\n   */\n  Dragger.prototype._onEnd = function(e) {\n    if (!this._getTrackedTouch(e)) return;\n\n    this._emit(events.end, e);\n    this._reset();\n  };\n\n  /**\n   * Public prototype methods\n   * ************************\n   */\n\n  /**\n   * Check if the element is being dragged at the moment.\n   *\n   * @public\n   * @memberof Dragger.prototype\n   * @returns {Boolean}\n   */\n  Dragger.prototype.isDragging = function() {\n    return this._pointerId !== null;\n  };\n\n  /**\n   * Set element's touch-action CSS property.\n   *\n   * @public\n   * @memberof Dragger.prototype\n   * @param {String} value\n   */\n  Dragger.prototype.setTouchAction = function(value) {\n    // Store unmodified touch action value (we trust user input here).\n    this._touchAction = value;\n\n    // Set touch-action style.\n    if (taPropPrefixed) {\n      this._cssProps[taPropPrefixed] = '';\n      this._element.style[taPropPrefixed] = value;\n    }\n\n    // If we have an unsupported touch-action value let's add a special listener\n    // that prevents default action on touch start event. A dirty hack, but best\n    // we can do for now. The other options would be to somehow polyfill the\n    // unsupported touch action behavior with custom heuristics which sounds like\n    // a can of worms.\n    if (hasTouchEvents) {\n      this._element.removeEventListener(Dragger._touchEvents.start, Dragger._preventDefault, false);\n      if (this._element.style[taPropPrefixed] !== value) {\n        this._element.addEventListener(Dragger._touchEvents.start, Dragger._preventDefault, false);\n      }\n    }\n  };\n\n  /**\n   * Update element's CSS properties. Accepts an object with camel cased style\n   * props with value pairs as it's first argument.\n   *\n   * @public\n   * @memberof Dragger.prototype\n   * @param {Object} [newProps]\n   */\n  Dragger.prototype.setCssProps = function(newProps) {\n    if (!newProps) return;\n\n    var currentProps = this._cssProps;\n    var element = this._element;\n    var prop;\n    var prefixedProp;\n\n    // Reset current props.\n    for (prop in currentProps) {\n      element.style[prop] = currentProps[prop];\n      delete currentProps[prop];\n    }\n\n    // Set new props.\n    for (prop in newProps) {\n      // Make sure we have a value for the prop.\n      if (!newProps[prop]) continue;\n\n      // Special handling for touch-action.\n      if (prop === taProp) {\n        this.setTouchAction(newProps[prop]);\n        continue;\n      }\n\n      // Get prefixed prop and skip if it does not exist.\n      prefixedProp = getPrefixedPropName(element.style, prop);\n      if (!prefixedProp) continue;\n\n      // Store the prop and add the style.\n      currentProps[prefixedProp] = '';\n      element.style[prefixedProp] = newProps[prop];\n    }\n  };\n\n  /**\n   * How much the pointer has moved on x-axis from start position, in pixels.\n   * Positive value indicates movement from left to right.\n   *\n   * @public\n   * @memberof Dragger.prototype\n   * @returns {Number}\n   */\n  Dragger.prototype.getDeltaX = function() {\n    return this._currentX - this._startX;\n  };\n\n  /**\n   * How much the pointer has moved on y-axis from start position, in pixels.\n   * Positive value indicates movement from top to bottom.\n   *\n   * @public\n   * @memberof Dragger.prototype\n   * @returns {Number}\n   */\n  Dragger.prototype.getDeltaY = function() {\n    return this._currentY - this._startY;\n  };\n\n  /**\n   * How far (in pixels) has pointer moved from start position.\n   *\n   * @public\n   * @memberof Dragger.prototype\n   * @returns {Number}\n   */\n  Dragger.prototype.getDistance = function() {\n    var x = this.getDeltaX();\n    var y = this.getDeltaY();\n    return Math.sqrt(x * x + y * y);\n  };\n\n  /**\n   * How long has pointer been dragged.\n   *\n   * @public\n   * @memberof Dragger.prototype\n   * @returns {Number}\n   */\n  Dragger.prototype.getDeltaTime = function() {\n    return this._startTime ? Date.now() - this._startTime : 0;\n  };\n\n  /**\n   * Bind drag event listeners.\n   *\n   * @public\n   * @memberof Dragger.prototype\n   * @param {String} eventName\n   *   - 'start', 'move', 'cancel' or 'end'.\n   * @param {Function} listener\n   */\n  Dragger.prototype.on = function(eventName, listener) {\n    this._emitter.on(eventName, listener);\n  };\n\n  /**\n   * Unbind drag event listeners.\n   *\n   * @public\n   * @memberof Dragger.prototype\n   * @param {String} eventName\n   *   - 'start', 'move', 'cancel' or 'end'.\n   * @param {Function} listener\n   */\n  Dragger.prototype.off = function(events, listener) {\n    this._emitter.off(eventName, listener);\n  };\n\n  /**\n   * Destroy the instance and unbind all drag event listeners.\n   *\n   * @public\n   * @memberof Dragger.prototype\n   */\n  Dragger.prototype.destroy = function() {\n    if (this._isDestroyed) return;\n\n    var element = this._element;\n    var events = Dragger._events;\n\n    // Reset data and deactivate the instance.\n    this._reset();\n\n    // Destroy emitter.\n    this._emitter.destroy();\n\n    // Unbind event handlers.\n    element.removeEventListener(events.start, this._preStartCheck, listenerOptions);\n    element.removeEventListener(Dragger._mouseEvents.start, this._preStartCheck, listenerOptions);\n    element.removeEventListener('dragstart', Dragger._preventDefault, false);\n    element.removeEventListener(Dragger._touchEvents.start, Dragger._preventDefault, false);\n\n    // Reset styles.\n    for (var prop in this._cssProps) {\n      element.style[prop] = this._cssProps[prop];\n      delete this._cssProps[prop];\n    }\n\n    // Reset data.\n    this._element = null;\n\n    // Mark as destroyed.\n    this._isDestroyed = true;\n  };\n\n  /**\n   * A ticker system for handling DOM reads and writes in an efficient way.\n   * Contains a read queue and a write queue that are processed on the next\n   * animation frame when needed.\n   *\n   * @class\n   */\n  function Ticker() {\n    this._nextStep = null;\n\n    this._queue = [];\n    this._reads = {};\n    this._writes = {};\n\n    this._batch = [];\n    this._batchReads = {};\n    this._batchWrites = {};\n\n    this._step = this._step.bind(this);\n  }\n\n  Ticker.prototype.add = function(id, readOperation, writeOperation, isPrioritized) {\n    // First, let's check if an item has been added to the queues with the same id\n    // and if so -> remove it.\n    var currentIndex = this._queue.indexOf(id);\n    if (currentIndex > -1) this._queue[currentIndex] = undefined;\n\n    // Add entry.\n    isPrioritized ? this._queue.unshift(id) : this._queue.push(id);\n    this._reads[id] = readOperation;\n    this._writes[id] = writeOperation;\n\n    // Finally, let's kick-start the next tick if it is not running yet.\n    if (!this._nextStep) this._nextStep = raf(this._step);\n  };\n\n  Ticker.prototype.cancel = function(id) {\n    var currentIndex = this._queue.indexOf(id);\n    if (currentIndex > -1) {\n      this._queue[currentIndex] = undefined;\n      delete this._reads[id];\n      delete this._writes[id];\n    }\n  };\n\n  Ticker.prototype._step = function() {\n    var queue = this._queue;\n    var reads = this._reads;\n    var writes = this._writes;\n    var batch = this._batch;\n    var batchReads = this._batchReads;\n    var batchWrites = this._batchWrites;\n    var length = queue.length;\n    var id;\n    var i;\n\n    // Reset ticker.\n    this._nextStep = null;\n\n    // Setup queues and callback placeholders.\n    for (i = 0; i < length; i++) {\n      id = queue[i];\n      if (!id) continue;\n\n      batch.push(id);\n\n      batchReads[id] = reads[id];\n      delete reads[id];\n\n      batchWrites[id] = writes[id];\n      delete writes[id];\n    }\n\n    // Reset queue.\n    queue.length = 0;\n\n    // Process read callbacks.\n    for (i = 0; i < length; i++) {\n      id = batch[i];\n      if (batchReads[id]) {\n        batchReads[id]();\n        delete batchReads[id];\n      }\n    }\n\n    // Process write callbacks.\n    for (i = 0; i < length; i++) {\n      id = batch[i];\n      if (batchWrites[id]) {\n        batchWrites[id]();\n        delete batchWrites[id];\n      }\n    }\n\n    // Reset batch.\n    batch.length = 0;\n\n    // Restart the ticker if needed.\n    if (!this._nextStep && queue.length) {\n      this._nextStep = raf(this._step);\n    }\n  };\n\n  var ticker = new Ticker();\n\n  var layoutTick = 'layout';\n  var visibilityTick = 'visibility';\n  var moveTick = 'move';\n  var scrollTick = 'scroll';\n  var placeholderTick = 'placeholder';\n\n  function addLayoutTick(itemId, readCallback, writeCallback) {\n    return ticker.add(itemId + layoutTick, readCallback, writeCallback);\n  }\n\n  function cancelLayoutTick(itemId) {\n    return ticker.cancel(itemId + layoutTick);\n  }\n\n  function addVisibilityTick(itemId, readCallback, writeCallback) {\n    return ticker.add(itemId + visibilityTick, readCallback, writeCallback);\n  }\n\n  function cancelVisibilityTick(itemId) {\n    return ticker.cancel(itemId + visibilityTick);\n  }\n\n  function addMoveTick(itemId, readCallback, writeCallback) {\n    return ticker.add(itemId + moveTick, readCallback, writeCallback, true);\n  }\n\n  function cancelMoveTick(itemId) {\n    return ticker.cancel(itemId + moveTick);\n  }\n\n  function addScrollTick(itemId, readCallback, writeCallback) {\n    return ticker.add(itemId + scrollTick, readCallback, writeCallback, true);\n  }\n\n  function cancelScrollTick(itemId) {\n    return ticker.cancel(itemId + scrollTick);\n  }\n\n  function addPlaceholderTick(itemId, readCallback, writeCallback) {\n    return ticker.add(itemId + placeholderTick, readCallback, writeCallback);\n  }\n\n  function cancelPlaceholderTick(itemId) {\n    return ticker.cancel(itemId + placeholderTick);\n  }\n\n  var ElProto = window.Element.prototype;\n  var matchesFn =\n    ElProto.matches ||\n    ElProto.matchesSelector ||\n    ElProto.webkitMatchesSelector ||\n    ElProto.mozMatchesSelector ||\n    ElProto.msMatchesSelector ||\n    ElProto.oMatchesSelector ||\n    function() {\n      return false;\n    };\n\n  /**\n   * Check if element matches a CSS selector.\n   *\n   * @param {Element} el\n   * @param {String} selector\n   * @returns {Boolean}\n   */\n  function elementMatches(el, selector) {\n    return matchesFn.call(el, selector);\n  }\n\n  /**\n   * Add class to an element.\n   *\n   * @param {HTMLElement} element\n   * @param {String} className\n   */\n  function addClass(element, className) {\n    if (element.classList) {\n      element.classList.add(className);\n    } else {\n      if (!elementMatches(element, '.' + className)) {\n        element.className += ' ' + className;\n      }\n    }\n  }\n\n  var tempArray = [];\n  var numberType = 'number';\n\n  /**\n   * Insert an item or an array of items to array to a specified index. Mutates\n   * the array. The index can be negative in which case the items will be added\n   * to the end of the array.\n   *\n   * @param {Array} array\n   * @param {*} items\n   * @param {Number} [index=-1]\n   */\n  function arrayInsert(array, items, index) {\n    var startIndex = typeof index === numberType ? index : -1;\n    if (startIndex < 0) startIndex = array.length - startIndex + 1;\n\n    array.splice.apply(array, tempArray.concat(startIndex, 0, items));\n    tempArray.length = 0;\n  }\n\n  /**\n   * Normalize array index. Basically this function makes sure that the provided\n   * array index is within the bounds of the provided array and also transforms\n   * negative index to the matching positive index.\n   *\n   * @param {Array} array\n   * @param {Number} index\n   * @param {Boolean} isMigration\n   */\n  function normalizeArrayIndex(array, index, isMigration) {\n    var length = array.length;\n    var maxIndex = Math.max(0, isMigration ? length : length - 1);\n    return index > maxIndex ? maxIndex : index < 0 ? Math.max(maxIndex + index + 1, 0) : index;\n  }\n\n  /**\n   * Move array item to another index.\n   *\n   * @param {Array} array\n   * @param {Number} fromIndex\n   *   - Index (positive or negative) of the item that will be moved.\n   * @param {Number} toIndex\n   *   - Index (positive or negative) where the item should be moved to.\n   */\n  function arrayMove(array, fromIndex, toIndex) {\n    // Make sure the array has two or more items.\n    if (array.length < 2) return;\n\n    // Normalize the indices.\n    var from = normalizeArrayIndex(array, fromIndex);\n    var to = normalizeArrayIndex(array, toIndex);\n\n    // Add target item to the new position.\n    if (from !== to) {\n      array.splice(to, 0, array.splice(from, 1)[0]);\n    }\n  }\n\n  /**\n   * Swap array items.\n   *\n   * @param {Array} array\n   * @param {Number} index\n   *   - Index (positive or negative) of the item that will be swapped.\n   * @param {Number} withIndex\n   *   - Index (positive or negative) of the other item that will be swapped.\n   */\n  function arraySwap(array, index, withIndex) {\n    // Make sure the array has two or more items.\n    if (array.length < 2) return;\n\n    // Normalize the indices.\n    var indexA = normalizeArrayIndex(array, index);\n    var indexB = normalizeArrayIndex(array, withIndex);\n    var temp;\n\n    // Swap the items.\n    if (indexA !== indexB) {\n      temp = array[indexA];\n      array[indexA] = array[indexB];\n      array[indexB] = temp;\n    }\n  }\n\n  var actionCancel = 'cancel';\n  var actionFinish = 'finish';\n  var debounceTick = 'debounce';\n  var debounceId = 0;\n\n  /**\n   * Returns a function, that, as long as it continues to be invoked, will not\n   * be triggered. The function will be called after it stops being called for\n   * N milliseconds. The returned function accepts one argument which, when\n   * being \"finish\", calls the debounce function immediately if it is currently\n   * waiting to be called, and when being \"cancel\" cancels the currently queued\n   * function call.\n   *\n   * @param {Function} fn\n   * @param {Number} wait\n   * @returns {Function}\n   */\n  function debounce(fn, wait) {\n    var timeout;\n    var tickerId = ++debounceId + debounceTick;\n\n    if (wait > 0) {\n      return function(action) {\n        if (timeout !== undefined) {\n          timeout = window.clearTimeout(timeout);\n          ticker.cancel(tickerId);\n          if (action === actionFinish) fn();\n        }\n\n        if (action !== actionCancel && action !== actionFinish) {\n          timeout = window.setTimeout(function() {\n            timeout = undefined;\n            ticker.add(tickerId, fn, null, true);\n          }, wait);\n        }\n      };\n    }\n\n    return function(action) {\n      if (action !== actionCancel) fn();\n    };\n  }\n\n  /**\n   * Returns true if element is transformed, false if not. In practice the\n   * element's display value must be anything else than \"none\" or \"inline\" as\n   * well as have a valid transform value applied in order to be counted as a\n   * transformed element.\n   *\n   * Borrowed from Mezr (v0.6.1):\n   * https://github.com/niklasramo/mezr/blob/0.6.1/mezr.js#L661\n   *\n   * @param {HTMLElement} element\n   * @returns {Boolean}\n   */\n  function isTransformed(element) {\n    var transform = getStyle(element, 'transform');\n    if (!transform || transform === 'none') return false;\n\n    var display = getStyle(element, 'display');\n    if (display === 'inline' || display === 'none') return false;\n\n    return true;\n  }\n\n  /**\n   * Returns an absolute positioned element's containing block, which is\n   * considered to be the closest ancestor element that the target element's\n   * positioning is relative to. Disclaimer: this only works as intended for\n   * absolute positioned elements.\n   *\n   * @param {HTMLElement} element\n   * @param {Boolean} [includeSelf=false]\n   *   - When this is set to true the containing block checking is started from\n   *     the provided element. Otherwise the checking is started from the\n   *     provided element's parent element.\n   * @returns {(Document|Element)}\n   */\n  function getContainingBlock(element, includeSelf) {\n    // As long as the containing block is an element, static and not\n    // transformed, try to get the element's parent element and fallback to\n    // document. https://github.com/niklasramo/mezr/blob/0.6.1/mezr.js#L339\n    var document = window.document;\n    var ret = (includeSelf ? element : element.parentElement) || document;\n    while (ret && ret !== document && getStyle(ret, 'position') === 'static' && !isTransformed(ret)) {\n      ret = ret.parentElement || document;\n    }\n    return ret;\n  }\n\n  /**\n   * Returns the computed value of an element's style property transformed into\n   * a float value.\n   *\n   * @param {HTMLElement} el\n   * @param {String} style\n   * @returns {Number}\n   */\n  function getStyleAsFloat(el, style) {\n    return parseFloat(getStyle(el, style)) || 0;\n  }\n\n  var offsetA = {};\n  var offsetB = {};\n  var offsetDiff = {};\n\n  /**\n   * Returns the element's document offset, which in practice means the vertical\n   * and horizontal distance between the element's northwest corner and the\n   * document's northwest corner. Note that this function always returns the same\n   * object so be sure to read the data from it instead using it as a reference.\n   *\n   * @param {(Document|Element|Window)} element\n   * @param {Object} [offsetData]\n   *   - Optional data object where the offset data will be inserted to. If not\n   *     provided a new object will be created for the return data.\n   * @returns {Object}\n   */\n  function getOffset(element, offsetData) {\n    var ret = offsetData || {};\n    var rect;\n\n    // Set up return data.\n    ret.left = 0;\n    ret.top = 0;\n\n    // Document's offsets are always 0.\n    if (element === document) return ret;\n\n    // Add viewport scroll left/top to the respective offsets.\n    ret.left = window.pageXOffset || 0;\n    ret.top = window.pageYOffset || 0;\n\n    // Window's offsets are the viewport scroll left/top values.\n    if (element.self === window.self) return ret;\n\n    // Add element's client rects to the offsets.\n    rect = element.getBoundingClientRect();\n    ret.left += rect.left;\n    ret.top += rect.top;\n\n    // Exclude element's borders from the offset.\n    ret.left += getStyleAsFloat(element, 'border-left-width');\n    ret.top += getStyleAsFloat(element, 'border-top-width');\n\n    return ret;\n  }\n\n  /**\n   * Calculate the offset difference two elements.\n   *\n   * @param {HTMLElement} elemA\n   * @param {HTMLElement} elemB\n   * @param {Boolean} [compareContainingBlocks=false]\n   *   - When this is set to true the containing blocks of the provided elements\n   *     will be used for calculating the difference. Otherwise the provided\n   *     elements will be compared directly.\n   * @returns {Object}\n   */\n  function getOffsetDiff(elemA, elemB, compareContainingBlocks) {\n    offsetDiff.left = 0;\n    offsetDiff.top = 0;\n\n    // If elements are same let's return early.\n    if (elemA === elemB) return offsetDiff;\n\n    // Compare containing blocks if necessary.\n    if (compareContainingBlocks) {\n      elemA = getContainingBlock(elemA, true);\n      elemB = getContainingBlock(elemB, true);\n\n      // If containing blocks are identical, let's return early.\n      if (elemA === elemB) return offsetDiff;\n    }\n\n    // Finally, let's calculate the offset diff.\n    getOffset(elemA, offsetA);\n    getOffset(elemB, offsetB);\n    offsetDiff.left = offsetB.left - offsetA.left;\n    offsetDiff.top = offsetB.top - offsetA.top;\n\n    return offsetDiff;\n  }\n\n  var styleOverflow = 'overflow';\n  var styleOverflowX = 'overflow-x';\n  var styleOverflowY = 'overflow-y';\n  var overflowAuto = 'auto';\n  var overflowScroll = 'scroll';\n\n  /**\n   * Check if an element is scrollable.\n   *\n   * @param {HTMLElement} element\n   * @returns {Boolean}\n   */\n  function isScrollable(element) {\n    var overflow = getStyle(element, styleOverflow);\n    if (overflow === overflowAuto || overflow === overflowScroll) return true;\n\n    overflow = getStyle(element, styleOverflowX);\n    if (overflow === overflowAuto || overflow === overflowScroll) return true;\n\n    overflow = getStyle(element, styleOverflowY);\n    if (overflow === overflowAuto || overflow === overflowScroll) return true;\n\n    return false;\n  }\n\n  /**\n   * Collect element's ancestors that are potentially scrollable elements.\n   *\n   * @param {HTMLElement} element\n   * @param {Boolean} [includeSelf=false]\n   * @param {Array} [data]\n   * @returns {Array}\n   */\n  function getScrollableAncestors(element, includeSelf, data) {\n    var ret = data || [];\n    var parent = includeSelf ? element : element.parentNode;\n\n    // Find scroll parents.\n    while (parent && parent !== document) {\n      // If element is inside ShadowDOM let's get it's host node from the real\n      // DOM and continue looping.\n      if (parent.getRootNode && parent instanceof DocumentFragment) {\n        parent = parent.getRootNode().host;\n        continue;\n      }\n\n      // If element is scrollable let's add it to the scrollable list.\n      if (isScrollable(parent)) {\n        ret.push(parent);\n      }\n\n      parent = parent.parentNode;\n    }\n\n    // Always add window to the results.\n    ret.push(window);\n\n    return ret;\n  }\n\n  var translateValue = {};\n  var transformStyle$2 = 'transform';\n  var transformNone = 'none';\n  var rxMat3d = /^matrix3d/;\n  var rxMatTx = /([^,]*,){4}/;\n  var rxMat3dTx = /([^,]*,){12}/;\n  var rxNextItem = /[^,]*,/;\n\n  /**\n   * Returns the element's computed translateX and translateY values as a floats.\n   * The returned object is always the same object and updated every time this\n   * function is called.\n   *\n   * @param {HTMLElement} element\n   * @returns {Object}\n   */\n  function getTranslate(element) {\n    translateValue.x = 0;\n    translateValue.y = 0;\n\n    var transform = getStyle(element, transformStyle$2);\n    if (!transform || transform === transformNone) {\n      return translateValue;\n    }\n\n    // Transform style can be in either matrix3d(...) or matrix(...).\n    var isMat3d = rxMat3d.test(transform);\n    var tX = transform.replace(isMat3d ? rxMat3dTx : rxMatTx, '');\n    var tY = tX.replace(rxNextItem, '');\n\n    translateValue.x = parseFloat(tX) || 0;\n    translateValue.y = parseFloat(tY) || 0;\n\n    return translateValue;\n  }\n\n  /**\n   * Transform translateX and translateY value into CSS transform style\n   * property's value.\n   *\n   * @param {Number} x\n   * @param {Number} y\n   * @returns {String}\n   */\n  function getTranslateString(x, y) {\n    return 'translateX(' + x + 'px) translateY(' + y + 'px)';\n  }\n\n  /**\n   * Remove class from an element.\n   *\n   * @param {HTMLElement} element\n   * @param {String} className\n   */\n  function removeClass(element, className) {\n    if (element.classList) {\n      element.classList.remove(className);\n    } else {\n      if (elementMatches(element, '.' + className)) {\n        element.className = (' ' + element.className + ' ')\n          .replace(' ' + className + ' ', ' ')\n          .trim();\n      }\n    }\n  }\n\n  // Drag start predicate states.\n  var startPredicateInactive = 0;\n  var startPredicatePending = 1;\n  var startPredicateResolved = 2;\n  var startPredicateRejected = 3;\n\n  /**\n   * Bind touch interaction to an item.\n   *\n   * @class\n   * @param {Item} item\n   */\n  function ItemDrag(item) {\n    var element = item._element;\n    var grid = item.getGrid();\n    var settings = grid._settings;\n\n    this._item = item;\n    this._gridId = grid._id;\n    this._isDestroyed = false;\n    this._isMigrating = false;\n\n    // Start predicate data.\n    this._startPredicate = isFunction(settings.dragStartPredicate)\n      ? settings.dragStartPredicate\n      : ItemDrag.defaultStartPredicate;\n    this._startPredicateState = startPredicateInactive;\n    this._startPredicateResult = undefined;\n\n    // Data for drag sort predicate heuristics.\n    this._hBlockedIndex = null;\n    this._hX1 = 0;\n    this._hX2 = 0;\n    this._hY1 = 0;\n    this._hY2 = 0;\n\n    // Setup item's initial drag data.\n    this._reset();\n\n    // Bind the methods that needs binding.\n    this._preStartCheck = this._preStartCheck.bind(this);\n    this._preEndCheck = this._preEndCheck.bind(this);\n    this._onScroll = this._onScroll.bind(this);\n    this._prepareMove = this._prepareMove.bind(this);\n    this._applyMove = this._applyMove.bind(this);\n    this._prepareScroll = this._prepareScroll.bind(this);\n    this._applyScroll = this._applyScroll.bind(this);\n    this._checkOverlap = this._checkOverlap.bind(this);\n\n    // Create debounce overlap checker function.\n    var sortInterval = settings.dragSortHeuristics.sortInterval;\n    this._checkOverlapDebounce = debounce(this._checkOverlap, sortInterval);\n\n    // Init dragger.\n    this._dragger = new Dragger(element, settings.dragCssProps);\n    this._dragger.on('start', this._preStartCheck);\n    this._dragger.on('move', this._preStartCheck);\n    this._dragger.on('cancel', this._preEndCheck);\n    this._dragger.on('end', this._preEndCheck);\n  }\n\n  /**\n   * Public static methods\n   * *********************\n   */\n\n  /**\n   * Default drag start predicate handler that handles anchor elements\n   * gracefully. The return value of this function defines if the drag is\n   * started, rejected or pending. When true is returned the dragging is started\n   * and when false is returned the dragging is rejected. If nothing is returned\n   * the predicate will be called again on the next drag movement.\n   *\n   * @public\n   * @memberof ItemDrag\n   * @param {Item} item\n   * @param {DraggerEvent} event\n   * @param {Object} [options]\n   *   - An optional options object which can be used to pass the predicate\n   *     it's options manually. By default the predicate retrieves the options\n   *     from the grid's settings.\n   * @returns {Boolean}\n   */\n  ItemDrag.defaultStartPredicate = function(item, event, options) {\n    var drag = item._drag;\n    var predicate = drag._startPredicateData || drag._setupStartPredicate(options);\n\n    // Final event logic. At this stage return value does not matter anymore,\n    // the predicate is either resolved or it's not and there's nothing to do\n    // about it. Here we just reset data and if the item element is a link\n    // we follow it (if there has only been slight movement).\n    if (event.isFinal) {\n      drag._finishStartPredicate(event);\n      return;\n    }\n\n    // Find and store the handle element so we can check later on if the\n    // cursor is within the handle. If we have a handle selector let's find\n    // the corresponding element. Otherwise let's use the item element as the\n    // handle.\n    if (!predicate.handleElement) {\n      predicate.handleElement = drag._getStartPredicateHandle(event);\n      if (!predicate.handleElement) return false;\n    }\n\n    // If delay is defined let's keep track of the latest event and initiate\n    // delay if it has not been done yet.\n    if (predicate.delay) {\n      predicate.event = event;\n      if (!predicate.delayTimer) {\n        predicate.delayTimer = window.setTimeout(function() {\n          predicate.delay = 0;\n          if (drag._resolveStartPredicate(predicate.event)) {\n            drag._forceResolveStartPredicate(predicate.event);\n            drag._resetStartPredicate();\n          }\n        }, predicate.delay);\n      }\n    }\n\n    return drag._resolveStartPredicate(event);\n  };\n\n  /**\n   * Default drag sort predicate.\n   *\n   * @public\n   * @memberof ItemDrag\n   * @param {Item} item\n   * @param {Object} [options]\n   * @param {Number} [options.threshold=50]\n   * @param {String} [options.action='move']\n   * @returns {(Boolean|DragSortCommand)}\n   *   - Returns false if no valid index was found. Otherwise returns drag sort\n   *     command.\n   */\n  ItemDrag.defaultSortPredicate = (function() {\n    var itemRect = {};\n    var targetRect = {};\n    var returnData = {};\n    var rootGridArray = [];\n\n    function getTargetGrid(item, rootGrid, threshold) {\n      var target = null;\n      var dragSort = rootGrid._settings.dragSort;\n      var bestScore = -1;\n      var gridScore;\n      var grids;\n      var grid;\n      var i;\n\n      // Get potential target grids.\n      if (dragSort === true) {\n        rootGridArray[0] = rootGrid;\n        grids = rootGridArray;\n      } else {\n        grids = dragSort.call(rootGrid, item);\n      }\n\n      // Return immediately if there are no grids.\n      if (!Array.isArray(grids)) return target;\n\n      // Loop through the grids and get the best match.\n      for (i = 0; i < grids.length; i++) {\n        grid = grids[i];\n\n        // Filter out all destroyed grids.\n        if (grid._isDestroyed) continue;\n\n        // We need to update the grid's offsets and dimensions since they might\n        // have changed (e.g during scrolling).\n        grid._updateBoundingRect();\n\n        // Check how much dragged element overlaps the container element.\n        targetRect.width = grid._width;\n        targetRect.height = grid._height;\n        targetRect.left = grid._left;\n        targetRect.top = grid._top;\n        gridScore = getRectOverlapScore(itemRect, targetRect);\n\n        // Check if this grid is the best match so far.\n        if (gridScore > threshold && gridScore > bestScore) {\n          bestScore = gridScore;\n          target = grid;\n        }\n      }\n\n      // Always reset root grid array.\n      rootGridArray.length = 0;\n\n      return target;\n    }\n\n    return function(item, options) {\n      var drag = item._drag;\n      var rootGrid = drag._getGrid();\n\n      // Get drag sort predicate settings.\n      var sortThreshold = options && typeof options.threshold === 'number' ? options.threshold : 50;\n      var sortAction = options && options.action === actionSwap ? actionSwap : actionMove;\n\n      // Populate item rect data.\n      itemRect.width = item._width;\n      itemRect.height = item._height;\n      itemRect.left = drag._elementClientX;\n      itemRect.top = drag._elementClientY;\n\n      // Calculate the target grid.\n      var grid = getTargetGrid(item, rootGrid, sortThreshold);\n\n      // Return early if we found no grid container element that overlaps the\n      // dragged item enough.\n      if (!grid) return false;\n\n      var gridOffsetLeft = 0;\n      var gridOffsetTop = 0;\n      var matchScore = -1;\n      var matchIndex;\n      var hasValidTargets;\n      var target;\n      var score;\n      var i;\n\n      // If item is moved within it's originating grid adjust item's left and\n      // top props. Otherwise if item is moved to/within another grid get the\n      // container element's offset (from the element's content edge).\n      if (grid === rootGrid) {\n        itemRect.left = drag._gridX + item._marginLeft;\n        itemRect.top = drag._gridY + item._marginTop;\n      } else {\n        grid._updateBorders(1, 0, 1, 0);\n        gridOffsetLeft = grid._left + grid._borderLeft;\n        gridOffsetTop = grid._top + grid._borderTop;\n      }\n\n      // Loop through the target grid items and try to find the best match.\n      for (i = 0; i < grid._items.length; i++) {\n        target = grid._items[i];\n\n        // If the target item is not active or the target item is the dragged\n        // item let's skip to the next item.\n        if (!target._isActive || target === item) {\n          continue;\n        }\n\n        // Mark the grid as having valid target items.\n        hasValidTargets = true;\n\n        // Calculate the target's overlap score with the dragged item.\n        targetRect.width = target._width;\n        targetRect.height = target._height;\n        targetRect.left = target._left + target._marginLeft + gridOffsetLeft;\n        targetRect.top = target._top + target._marginTop + gridOffsetTop;\n        score = getRectOverlapScore(itemRect, targetRect);\n\n        // Update best match index and score if the target's overlap score with\n        // the dragged item is higher than the current best match score.\n        if (score > matchScore) {\n          matchIndex = i;\n          matchScore = score;\n        }\n      }\n\n      // If there is no valid match and the item is being moved into another\n      // grid.\n      if (matchScore < sortThreshold && item.getGrid() !== grid) {\n        matchIndex = hasValidTargets ? -1 : 0;\n        matchScore = Infinity;\n      }\n\n      // Check if the best match overlaps enough to justify a placement switch.\n      if (matchScore >= sortThreshold) {\n        returnData.grid = grid;\n        returnData.index = matchIndex;\n        returnData.action = sortAction;\n        return returnData;\n      }\n\n      return false;\n    };\n  })();\n\n  /**\n   * Public prototype methods\n   * ************************\n   */\n\n  /**\n   * Abort dragging and reset drag data.\n   *\n   * @public\n   * @memberof ItemDrag.prototype\n   * @returns {ItemDrag}\n   */\n  ItemDrag.prototype.stop = function() {\n    var item = this._item;\n    var element = item._element;\n    var grid = this._getGrid();\n\n    if (!this._isActive) return this;\n\n    // If the item is being dropped into another grid, finish it up and return\n    // immediately.\n    if (this._isMigrating) {\n      this._finishMigration();\n      return this;\n    }\n\n    // Cancel queued move and scroll ticks.\n    cancelMoveTick(item._id);\n    cancelScrollTick(item._id);\n\n    // Remove scroll listeners.\n    this._unbindScrollListeners();\n\n    // Cancel overlap check.\n    this._checkOverlapDebounce('cancel');\n\n    // Append item element to the container if it's not it's child. Also make\n    // sure the translate values are adjusted to account for the DOM shift.\n    if (element.parentNode !== grid._element) {\n      grid._element.appendChild(element);\n      element.style[transformProp] = getTranslateString(this._gridX, this._gridY);\n    }\n\n    // Remove dragging class.\n    removeClass(element, grid._settings.itemDraggingClass);\n\n    // Reset drag data.\n    this._reset();\n\n    return this;\n  };\n\n  /**\n   * Destroy instance.\n   *\n   * @public\n   * @memberof ItemDrag.prototype\n   * @returns {ItemDrag}\n   */\n  ItemDrag.prototype.destroy = function() {\n    if (this._isDestroyed) return this;\n    this.stop();\n    this._dragger.destroy();\n    this._isDestroyed = true;\n    return this;\n  };\n\n  /**\n   * Private prototype methods\n   * *************************\n   */\n\n  /**\n   * Get Grid instance.\n   *\n   * @private\n   * @memberof ItemDrag.prototype\n   * @returns {?Grid}\n   */\n  ItemDrag.prototype._getGrid = function() {\n    return gridInstances[this._gridId] || null;\n  };\n\n  /**\n   * Setup/reset drag data.\n   *\n   * @private\n   * @memberof ItemDrag.prototype\n   */\n  ItemDrag.prototype._reset = function() {\n    // Is item being dragged?\n    this._isActive = false;\n\n    // The dragged item's container element.\n    this._container = null;\n\n    // The dragged item's containing block.\n    this._containingBlock = null;\n\n    // Drag/scroll event data.\n    this._dragEvent = null;\n    this._scrollEvent = null;\n\n    // All the elements which need to be listened for scroll events during\n    // dragging.\n    this._scrollers = [];\n\n    // The current translateX/translateY position.\n    this._left = 0;\n    this._top = 0;\n\n    // Dragged element's current position within the grid.\n    this._gridX = 0;\n    this._gridY = 0;\n\n    // Dragged element's current offset from window's northwest corner. Does\n    // not account for element's margins.\n    this._elementClientX = 0;\n    this._elementClientY = 0;\n\n    // Offset difference between the dragged element's temporary drag\n    // container and it's original container.\n    this._containerDiffX = 0;\n    this._containerDiffY = 0;\n  };\n\n  /**\n   * Bind drag scroll handlers to all scrollable ancestor elements of the\n   * dragged element and the drag container element.\n   *\n   * @private\n   * @memberof ItemDrag.prototype\n   */\n  ItemDrag.prototype._bindScrollListeners = function() {\n    var gridContainer = this._getGrid()._element;\n    var dragContainer = this._container;\n    var scrollers = this._scrollers;\n    var gridScrollers;\n    var i;\n\n    // Get dragged element's scrolling parents.\n    scrollers.length = 0;\n    getScrollableAncestors(this._item._element, false, scrollers);\n\n    // If drag container is defined and it's not the same element as grid\n    // container then we need to add the grid container and it's scroll parents\n    // to the elements which are going to be listener for scroll events.\n    if (dragContainer !== gridContainer) {\n      gridScrollers = [];\n      getScrollableAncestors(gridContainer, true, gridScrollers);\n      for (i = 0; i < gridScrollers.length; i++) {\n        if (scrollers.indexOf(gridScrollers[i]) < 0) {\n          scrollers.push(gridScrollers[i]);\n        }\n      }\n    }\n\n    // Bind scroll listeners.\n    for (i = 0; i < scrollers.length; i++) {\n      scrollers[i].addEventListener('scroll', this._onScroll);\n    }\n  };\n\n  /**\n   * Unbind currently bound drag scroll handlers from all scrollable ancestor\n   * elements of the dragged element and the drag container element.\n   *\n   * @private\n   * @memberof ItemDrag.prototype\n   */\n  ItemDrag.prototype._unbindScrollListeners = function() {\n    var scrollers = this._scrollers;\n    var i;\n\n    for (i = 0; i < scrollers.length; i++) {\n      scrollers[i].removeEventListener('scroll', this._onScroll);\n    }\n\n    scrollers.length = 0;\n  };\n\n  /**\n   * Setup default start predicate.\n   *\n   * @private\n   * @memberof ItemDrag.prototype\n   * @param {Object} [options]\n   * @returns {Object}\n   */\n  ItemDrag.prototype._setupStartPredicate = function(options) {\n    var config = options || this._getGrid()._settings.dragStartPredicate || 0;\n    return (this._startPredicateData = {\n      distance: Math.abs(config.distance) || 0,\n      delay: Math.max(config.delay, 0) || 0,\n      handle: typeof config.handle === 'string' ? config.handle : false\n    });\n  };\n\n  /**\n   * Setup default start predicate handle.\n   *\n   * @private\n   * @memberof ItemDrag.prototype\n   * @param {DraggerEvent} event\n   * @returns {?HTMLElement}\n   */\n  ItemDrag.prototype._getStartPredicateHandle = function(event) {\n    var predicate = this._startPredicateData;\n    var element = this._item._element;\n    var handleElement = element;\n\n    // No handle, no hassle -> let's use the item element as the handle.\n    if (!predicate.handle) return handleElement;\n\n    // If there is a specific predicate handle defined, let's try to get it.\n    handleElement = event.target;\n    while (handleElement && !elementMatches(handleElement, predicate.handle)) {\n      handleElement = handleElement !== element ? handleElement.parentElement : null;\n    }\n    return handleElement || null;\n  };\n\n  /**\n   * Unbind currently bound drag scroll handlers from all scrollable ancestor\n   * elements of the dragged element and the drag container element.\n   *\n   * @private\n   * @memberof ItemDrag.prototype\n   * @param {DraggerEvent} event\n   * @returns {Boolean}\n   */\n  ItemDrag.prototype._resolveStartPredicate = function(event) {\n    var predicate = this._startPredicateData;\n\n    // If the moved distance is smaller than the threshold distance or there is\n    // some delay left, ignore this predicate cycle.\n    if (event.distance < predicate.distance || predicate.delay) return;\n\n    // Get handle rect data.\n    var handleRect = predicate.handleElement.getBoundingClientRect();\n    var handleLeft = handleRect.left + (window.pageXOffset || 0);\n    var handleTop = handleRect.top + (window.pageYOffset || 0);\n    var handleWidth = handleRect.width;\n    var handleHeight = handleRect.height;\n\n    // Reset predicate data.\n    this._resetStartPredicate();\n\n    // If the cursor is still within the handle let's start the drag.\n    return (\n      handleWidth &&\n      handleHeight &&\n      event.pageX >= handleLeft &&\n      event.pageX < handleLeft + handleWidth &&\n      event.pageY >= handleTop &&\n      event.pageY < handleTop + handleHeight\n    );\n  };\n\n  /**\n   * Forcefully resolve drag start predicate.\n   *\n   * @private\n   * @memberof ItemDrag.prototype\n   * @param {DraggerEvent} event\n   */\n  ItemDrag.prototype._forceResolveStartPredicate = function(event) {\n    if (!this._isDestroyed && this._startPredicateState === startPredicatePending) {\n      this._startPredicateState = startPredicateResolved;\n      this._onStart(event);\n    }\n  };\n\n  /**\n   * Finalize start predicate.\n   *\n   * @private\n   * @memberof ItemDrag.prototype\n   * @param {DraggerEvent} event\n   */\n  ItemDrag.prototype._finishStartPredicate = function(event) {\n    var element = this._item._element;\n\n    // Check if this is a click (very subjective heuristics).\n    var isClick = Math.abs(event.deltaX) < 2 && Math.abs(event.deltaY) < 2 && event.deltaTime < 200;\n\n    // Reset predicate.\n    this._resetStartPredicate();\n\n    // If the gesture can be interpreted as click let's try to open the element's\n    // href url (if it is an anchor element).\n    if (isClick) openAnchorHref(element);\n  };\n\n  /**\n   * Reset drag sort heuristics.\n   *\n   * @private\n   * @memberof ItemDrag.prototype\n   * @param {DraggerEvent} event\n   */\n  ItemDrag.prototype._resetHeuristics = function(event) {\n    this._hBlockedIndex = null;\n    this._hX1 = this._hX2 = event.clientX;\n    this._hY1 = this._hY2 = event.clientY;\n  };\n\n  /**\n   * Run heuristics and return true if overlap check can be performed, and false\n   * if it can not.\n   *\n   * @private\n   * @memberof ItemDrag.prototype\n   * @param {DraggerEvent} event\n   * @returns {Boolean}\n   */\n  ItemDrag.prototype._checkHeuristics = function(event) {\n    var settings = this._getGrid()._settings.dragSortHeuristics;\n    var minDist = settings.minDragDistance;\n\n    // Skip heuristics if not needed.\n    if (minDist <= 0) {\n      this._hBlockedIndex = null;\n      return true;\n    }\n\n    var x = event.clientX;\n    var y = event.clientY;\n    var diffX = x - this._hX2;\n    var diffY = y - this._hY2;\n\n    // If we can't do proper bounce back check make sure that the blocked index\n    // is not set.\n    var canCheckBounceBack = minDist > 3 && settings.minBounceBackAngle > 0;\n    if (!canCheckBounceBack) {\n      this._hBlockedIndex = null;\n    }\n\n    if (Math.abs(diffX) > minDist || Math.abs(diffY) > minDist) {\n      // Reset blocked index if angle changed enough. This check requires a\n      // minimum value of 3 for minDragDistance to function properly.\n      if (canCheckBounceBack) {\n        var angle = Math.atan2(diffX, diffY);\n        var prevAngle = Math.atan2(this._hX2 - this._hX1, this._hY2 - this._hY1);\n        var deltaAngle = Math.atan2(Math.sin(angle - prevAngle), Math.cos(angle - prevAngle));\n        if (Math.abs(deltaAngle) > settings.minBounceBackAngle) {\n          this._hBlockedIndex = null;\n        }\n      }\n\n      // Update points.\n      this._hX1 = this._hX2;\n      this._hY1 = this._hY2;\n      this._hX2 = x;\n      this._hY2 = y;\n\n      return true;\n    }\n\n    return false;\n  };\n\n  /**\n   * Reset for default drag start predicate function.\n   *\n   * @private\n   * @memberof ItemDrag.prototype\n   */\n  ItemDrag.prototype._resetStartPredicate = function() {\n    var predicate = this._startPredicateData;\n    if (predicate) {\n      if (predicate.delayTimer) {\n        predicate.delayTimer = window.clearTimeout(predicate.delayTimer);\n      }\n      this._startPredicateData = null;\n    }\n  };\n\n  /**\n   * Check (during drag) if an item is overlapping other items and based on\n   * the configuration layout the items.\n   *\n   * @private\n   * @memberof ItemDrag.prototype\n   */\n  ItemDrag.prototype._checkOverlap = function() {\n    if (!this._isActive) return;\n\n    var item = this._item;\n    var settings = this._getGrid()._settings;\n    var result;\n    var currentGrid;\n    var currentIndex;\n    var targetGrid;\n    var targetIndex;\n    var sortAction;\n    var isMigration;\n\n    // Get overlap check result.\n    if (isFunction(settings.dragSortPredicate)) {\n      result = settings.dragSortPredicate(item, this._dragEvent);\n    } else {\n      result = ItemDrag.defaultSortPredicate(item, settings.dragSortPredicate);\n    }\n\n    // Let's make sure the result object has a valid index before going further.\n    if (!result || typeof result.index !== 'number') return;\n\n    currentGrid = item.getGrid();\n    targetGrid = result.grid || currentGrid;\n    isMigration = currentGrid !== targetGrid;\n    currentIndex = currentGrid._items.indexOf(item);\n    targetIndex = normalizeArrayIndex(targetGrid._items, result.index, isMigration);\n    sortAction = result.action === actionSwap ? actionSwap : actionMove;\n\n    // Prevent position bounce.\n    if (!isMigration && targetIndex === this._hBlockedIndex) {\n      return;\n    }\n\n    // If the item was moved within it's current grid.\n    if (!isMigration) {\n      // Make sure the target index is not the current index.\n      if (currentIndex !== targetIndex) {\n        this._hBlockedIndex = currentIndex;\n\n        // Do the sort.\n        (sortAction === actionSwap ? arraySwap : arrayMove)(\n          currentGrid._items,\n          currentIndex,\n          targetIndex\n        );\n\n        // Emit move event.\n        if (currentGrid._hasListeners(eventMove)) {\n          currentGrid._emit(eventMove, {\n            item: item,\n            fromIndex: currentIndex,\n            toIndex: targetIndex,\n            action: sortAction\n          });\n        }\n\n        // Layout the grid.\n        currentGrid.layout();\n      }\n    }\n\n    // If the item was moved to another grid.\n    else {\n      this._hBlockedIndex = null;\n\n      // Emit beforeSend event.\n      if (currentGrid._hasListeners(eventBeforeSend)) {\n        currentGrid._emit(eventBeforeSend, {\n          item: item,\n          fromGrid: currentGrid,\n          fromIndex: currentIndex,\n          toGrid: targetGrid,\n          toIndex: targetIndex\n        });\n      }\n\n      // Emit beforeReceive event.\n      if (targetGrid._hasListeners(eventBeforeReceive)) {\n        targetGrid._emit(eventBeforeReceive, {\n          item: item,\n          fromGrid: currentGrid,\n          fromIndex: currentIndex,\n          toGrid: targetGrid,\n          toIndex: targetIndex\n        });\n      }\n\n      // Update item's grid id reference.\n      item._gridId = targetGrid._id;\n\n      // Update drag instance's migrating indicator.\n      this._isMigrating = item._gridId !== this._gridId;\n\n      // Move item instance from current grid to target grid.\n      currentGrid._items.splice(currentIndex, 1);\n      arrayInsert(targetGrid._items, item, targetIndex);\n\n      // Set sort data as null, which is an indicator for the item comparison\n      // function that the sort data of this specific item should be fetched\n      // lazily.\n      item._sortData = null;\n\n      // Emit send event.\n      if (currentGrid._hasListeners(eventSend)) {\n        currentGrid._emit(eventSend, {\n          item: item,\n          fromGrid: currentGrid,\n          fromIndex: currentIndex,\n          toGrid: targetGrid,\n          toIndex: targetIndex\n        });\n      }\n\n      // Emit receive event.\n      if (targetGrid._hasListeners(eventReceive)) {\n        targetGrid._emit(eventReceive, {\n          item: item,\n          fromGrid: currentGrid,\n          fromIndex: currentIndex,\n          toGrid: targetGrid,\n          toIndex: targetIndex\n        });\n      }\n\n      // Layout both grids.\n      currentGrid.layout();\n      targetGrid.layout();\n    }\n  };\n\n  /**\n   * If item is dragged into another grid, finish the migration process\n   * gracefully.\n   *\n   * @private\n   * @memberof ItemDrag.prototype\n   */\n  ItemDrag.prototype._finishMigration = function() {\n    var item = this._item;\n    var release = item._release;\n    var element = item._element;\n    var isActive = item._isActive;\n    var targetGrid = item.getGrid();\n    var targetGridElement = targetGrid._element;\n    var targetSettings = targetGrid._settings;\n    var targetContainer = targetSettings.dragContainer || targetGridElement;\n    var currentSettings = this._getGrid()._settings;\n    var currentContainer = element.parentNode;\n    var translate;\n    var offsetDiff;\n\n    // Destroy current drag. Note that we need to set the migrating flag to\n    // false first, because otherwise we create an infinite loop between this\n    // and the drag.stop() method.\n    this._isMigrating = false;\n    this.destroy();\n\n    // Remove current classnames.\n    removeClass(element, currentSettings.itemClass);\n    removeClass(element, currentSettings.itemVisibleClass);\n    removeClass(element, currentSettings.itemHiddenClass);\n\n    // Add new classnames.\n    addClass(element, targetSettings.itemClass);\n    addClass(element, isActive ? targetSettings.itemVisibleClass : targetSettings.itemHiddenClass);\n\n    // Move the item inside the target container if it's different than the\n    // current container.\n    if (targetContainer !== currentContainer) {\n      targetContainer.appendChild(element);\n      offsetDiff = getOffsetDiff(currentContainer, targetContainer, true);\n      translate = getTranslate(element);\n      translate.x -= offsetDiff.left;\n      translate.y -= offsetDiff.top;\n    }\n\n    // Update item's cached dimensions and sort data.\n    item._refreshDimensions();\n    item._refreshSortData();\n\n    // Calculate the offset difference between target's drag container (if any)\n    // and actual grid container element. We save it later for the release\n    // process.\n    offsetDiff = getOffsetDiff(targetContainer, targetGridElement, true);\n    release._containerDiffX = offsetDiff.left;\n    release._containerDiffY = offsetDiff.top;\n\n    // Recreate item's drag handler.\n    item._drag = targetSettings.dragEnabled ? new ItemDrag(item) : null;\n\n    // Adjust the position of the item element if it was moved from a container\n    // to another.\n    if (targetContainer !== currentContainer) {\n      element.style[transformProp] = getTranslateString(translate.x, translate.y);\n    }\n\n    // Update child element's styles to reflect the current visibility state.\n    item._child.removeAttribute('style');\n    setStyles(item._child, isActive ? targetSettings.visibleStyles : targetSettings.hiddenStyles);\n\n    // Start the release.\n    release.start();\n  };\n\n  /**\n   * Drag pre-start handler.\n   *\n   * @private\n   * @memberof ItemDrag.prototype\n   * @param {DraggerEvent} event\n   */\n  ItemDrag.prototype._preStartCheck = function(event) {\n    // Let's activate drag start predicate state.\n    if (this._startPredicateState === startPredicateInactive) {\n      this._startPredicateState = startPredicatePending;\n    }\n\n    // If predicate is pending try to resolve it.\n    if (this._startPredicateState === startPredicatePending) {\n      this._startPredicateResult = this._startPredicate(this._item, event);\n      if (this._startPredicateResult === true) {\n        this._startPredicateState = startPredicateResolved;\n        this._onStart(event);\n      } else if (this._startPredicateResult === false) {\n        this._startPredicateState = startPredicateRejected;\n      }\n    }\n\n    // Otherwise if predicate is resolved and drag is active, move the item.\n    else if (this._startPredicateState === startPredicateResolved && this._isActive) {\n      this._onMove(event);\n    }\n  };\n\n  /**\n   * Drag pre-end handler.\n   *\n   * @private\n   * @memberof ItemDrag.prototype\n   * @param {DraggerEvent} event\n   */\n  ItemDrag.prototype._preEndCheck = function(event) {\n    // Check if the start predicate was resolved during drag.\n    var isResolved = this._startPredicateState === startPredicateResolved;\n\n    // Do final predicate check to allow user to unbind stuff for the current\n    // drag procedure within the predicate callback. The return value of this\n    // check will have no effect to the state of the predicate.\n    this._startPredicate(this._item, event);\n\n    // Reset start predicate state.\n    this._startPredicateState = startPredicateInactive;\n\n    // If predicate is resolved and dragging is active, call the end handler.\n    if (isResolved && this._isActive) this._onEnd(event);\n  };\n\n  /**\n   * Drag start handler.\n   *\n   * @private\n   * @memberof ItemDrag.prototype\n   * @param {DraggerEvent} event\n   */\n  ItemDrag.prototype._onStart = function(event) {\n    var item = this._item;\n\n    // If item is not active, don't start the drag.\n    if (!item._isActive) return;\n\n    var element = item._element;\n    var grid = this._getGrid();\n    var settings = grid._settings;\n    var release = item._release;\n    var migrate = item._migrate;\n    var gridContainer = grid._element;\n    var dragContainer = settings.dragContainer || gridContainer;\n    var containingBlock = getContainingBlock(dragContainer, true);\n    var translate = getTranslate(element);\n    var currentLeft = translate.x;\n    var currentTop = translate.y;\n    var elementRect = element.getBoundingClientRect();\n    var hasDragContainer = dragContainer !== gridContainer;\n    var offsetDiff;\n\n    // Reset heuristics data.\n    this._resetHeuristics(event);\n\n    // If grid container is not the drag container, we need to calculate the\n    // offset difference between grid container and drag container's containing\n    // element.\n    if (hasDragContainer) {\n      offsetDiff = getOffsetDiff(containingBlock, gridContainer);\n    }\n\n    // Stop current positioning animation.\n    if (item.isPositioning()) {\n      item._layout.stop(true, { transform: getTranslateString(currentLeft, currentTop) });\n    }\n\n    // Stop current migration animation.\n    if (migrate._isActive) {\n      currentLeft -= migrate._containerDiffX;\n      currentTop -= migrate._containerDiffY;\n      migrate.stop(true, { transform: getTranslateString(currentLeft, currentTop) });\n    }\n\n    // If item is being released reset release data.\n    if (item.isReleasing()) release._reset();\n\n    // Setup drag data.\n    this._isActive = true;\n    this._dragEvent = event;\n    this._container = dragContainer;\n    this._containingBlock = containingBlock;\n    this._elementClientX = elementRect.left;\n    this._elementClientY = elementRect.top;\n    this._left = this._gridX = currentLeft;\n    this._top = this._gridY = currentTop;\n\n    // Create placeholder (if necessary).\n    if (settings.dragPlaceholder.enabled) {\n      item._dragPlaceholder.create();\n    }\n\n    // Emit dragInit event.\n    grid._emit(eventDragInit, item, event);\n\n    // If a specific drag container is set and it is different from the\n    // grid's container element we need to cast some extra spells.\n    if (hasDragContainer) {\n      // Store the container offset diffs to drag data.\n      this._containerDiffX = offsetDiff.left;\n      this._containerDiffY = offsetDiff.top;\n\n      // If the dragged element is a child of the drag container all we need to\n      // do is setup the relative drag position data.\n      if (element.parentNode === dragContainer) {\n        this._gridX = currentLeft - this._containerDiffX;\n        this._gridY = currentTop - this._containerDiffY;\n      }\n\n      // Otherwise we need to append the element inside the correct container,\n      // setup the actual drag position data and adjust the element's translate\n      // values to account for the DOM position shift.\n      else {\n        this._left = currentLeft + this._containerDiffX;\n        this._top = currentTop + this._containerDiffY;\n        dragContainer.appendChild(element);\n        element.style[transformProp] = getTranslateString(this._left, this._top);\n      }\n    }\n\n    // Set drag class and bind scrollers.\n    addClass(element, settings.itemDraggingClass);\n    this._bindScrollListeners();\n\n    // Emit dragStart event.\n    grid._emit(eventDragStart, item, event);\n  };\n\n  /**\n   * Drag move handler.\n   *\n   * @private\n   * @memberof ItemDrag.prototype\n   * @param {DraggerEvent} event\n   */\n  ItemDrag.prototype._onMove = function(event) {\n    var item = this._item;\n\n    // If item is not active, reset drag.\n    if (!item._isActive) {\n      this.stop();\n      return;\n    }\n\n    var settings = this._getGrid()._settings;\n    var axis = settings.dragAxis;\n\n    // Update horizontal position data.\n    if (axis !== 'y') {\n      var xDiff = event.clientX - this._dragEvent.clientX;\n      this._left += xDiff;\n      this._gridX += xDiff;\n      this._elementClientX += xDiff;\n    }\n\n    // Update vertical position data.\n    if (axis !== 'x') {\n      var yDiff = event.clientY - this._dragEvent.clientY;\n      this._top += yDiff;\n      this._gridY += yDiff;\n      this._elementClientY += yDiff;\n    }\n\n    // Update event data.\n    this._dragEvent = event;\n\n    // Do move prepare/apply handling in the next tick.\n    addMoveTick(item._id, this._prepareMove, this._applyMove);\n  };\n\n  /**\n   * Prepare dragged item for moving.\n   *\n   * @private\n   * @memberof ItemDrag.prototype\n   */\n  ItemDrag.prototype._prepareMove = function() {\n    // Do nothing if item is not active.\n    if (!this._item._isActive) return;\n\n    // If drag sort is enabled -> check overlap.\n    if (this._getGrid()._settings.dragSort) {\n      if (this._checkHeuristics(this._dragEvent)) {\n        this._checkOverlapDebounce();\n      }\n    }\n  };\n\n  /**\n   * Apply movement to dragged item.\n   *\n   * @private\n   * @memberof ItemDrag.prototype\n   */\n  ItemDrag.prototype._applyMove = function() {\n    var item = this._item;\n\n    // Do nothing if item is not active.\n    if (!item._isActive) return;\n\n    // Update element's translateX/Y values.\n    item._element.style[transformProp] = getTranslateString(this._left, this._top);\n\n    // Emit dragMove event.\n    this._getGrid()._emit(eventDragMove, item, this._dragEvent);\n  };\n\n  /**\n   * Drag scroll handler.\n   *\n   * @private\n   * @memberof ItemDrag.prototype\n   * @param {Event} event\n   */\n  ItemDrag.prototype._onScroll = function(event) {\n    var item = this._item;\n\n    // If item is not active, reset drag.\n    if (!item._isActive) {\n      this.stop();\n      return;\n    }\n\n    // Update last scroll event.\n    this._scrollEvent = event;\n\n    // Do scroll prepare/apply handling in the next tick.\n    addScrollTick(item._id, this._prepareScroll, this._applyScroll);\n  };\n\n  /**\n   * Prepare dragged item for scrolling.\n   *\n   * @private\n   * @memberof ItemDrag.prototype\n   */\n  ItemDrag.prototype._prepareScroll = function() {\n    var item = this._item;\n\n    // If item is not active do nothing.\n    if (!item._isActive) return;\n\n    var element = item._element;\n    var grid = this._getGrid();\n    var settings = grid._settings;\n    var axis = settings.dragAxis;\n    var gridContainer = grid._element;\n    var offsetDiff;\n\n    // Calculate element's rect and x/y diff.\n    var rect = element.getBoundingClientRect();\n    var xDiff = this._elementClientX - rect.left;\n    var yDiff = this._elementClientY - rect.top;\n\n    // Update container diff.\n    if (this._container !== gridContainer) {\n      offsetDiff = getOffsetDiff(this._containingBlock, gridContainer);\n      this._containerDiffX = offsetDiff.left;\n      this._containerDiffY = offsetDiff.top;\n    }\n\n    // Update horizontal position data.\n    if (axis !== 'y') {\n      this._left += xDiff;\n      this._gridX = this._left - this._containerDiffX;\n    }\n\n    // Update vertical position data.\n    if (axis !== 'x') {\n      this._top += yDiff;\n      this._gridY = this._top - this._containerDiffY;\n    }\n\n    // Overlap handling.\n    if (settings.dragSort) this._checkOverlapDebounce();\n  };\n\n  /**\n   * Apply scroll to dragged item.\n   *\n   * @private\n   * @memberof ItemDrag.prototype\n   */\n  ItemDrag.prototype._applyScroll = function() {\n    var item = this._item;\n\n    // If item is not active do nothing.\n    if (!item._isActive) return;\n\n    // Update element's translateX/Y values.\n    item._element.style[transformProp] = getTranslateString(this._left, this._top);\n\n    // Emit dragScroll event.\n    this._getGrid()._emit(eventDragScroll, item, this._scrollEvent);\n  };\n\n  /**\n   * Drag end handler.\n   *\n   * @private\n   * @memberof ItemDrag.prototype\n   * @param {DraggerEvent} event\n   */\n  ItemDrag.prototype._onEnd = function(event) {\n    var item = this._item;\n    var element = item._element;\n    var grid = this._getGrid();\n    var settings = grid._settings;\n    var release = item._release;\n\n    // If item is not active, reset drag.\n    if (!item._isActive) {\n      this.stop();\n      return;\n    }\n\n    // Cancel queued move and scroll ticks.\n    cancelMoveTick(item._id);\n    cancelScrollTick(item._id);\n\n    // Finish currently queued overlap check.\n    settings.dragSort && this._checkOverlapDebounce('finish');\n\n    // Remove scroll listeners.\n    this._unbindScrollListeners();\n\n    // Setup release data.\n    release._containerDiffX = this._containerDiffX;\n    release._containerDiffY = this._containerDiffY;\n\n    // Reset drag data.\n    this._reset();\n\n    // Remove drag class name from element.\n    removeClass(element, settings.itemDraggingClass);\n\n    // Emit dragEnd event.\n    grid._emit(eventDragEnd, item, event);\n\n    // Finish up the migration process or start the release process.\n    this._isMigrating ? this._finishMigration() : release.start();\n  };\n\n  /**\n   * Private helpers\n   * ***************\n   */\n\n  /**\n   * Calculate how many percent the intersection area of two rectangles is from\n   * the maximum potential intersection area between the rectangles.\n   *\n   * @param {Rectangle} a\n   * @param {Rectangle} b\n   * @returns {Number}\n   *   - A number between 0-100.\n   */\n  function getRectOverlapScore(a, b) {\n    // Return 0 immediately if the rectangles do not overlap.\n    if (\n      a.left + a.width <= b.left ||\n      b.left + b.width <= a.left ||\n      a.top + a.height <= b.top ||\n      b.top + b.height <= a.top\n    ) {\n      return 0;\n    }\n\n    // Calculate intersection area's width, height, max height and max width.\n    var width = Math.min(a.left + a.width, b.left + b.width) - Math.max(a.left, b.left);\n    var height = Math.min(a.top + a.height, b.top + b.height) - Math.max(a.top, b.top);\n    var maxWidth = Math.min(a.width, b.width);\n    var maxHeight = Math.min(a.height, b.height);\n\n    return ((width * height) / (maxWidth * maxHeight)) * 100;\n  }\n\n  /**\n   * Check if an element is an anchor element and open the href url if possible.\n   *\n   * @param {HTMLElement} element\n   */\n  function openAnchorHref(element) {\n    // Make sure the element is anchor element.\n    if (element.tagName.toLowerCase() !== 'a') return;\n\n    // Get href and make sure it exists.\n    var href = element.getAttribute('href');\n    if (!href) return;\n\n    // Finally let's navigate to the link href.\n    var target = element.getAttribute('target');\n    if (target && target !== '_self') {\n      window.open(href, target);\n    } else {\n      window.location.href = href;\n    }\n  }\n\n  /**\n   * Drag placeholder.\n   *\n   * @class\n   * @param {Item} item\n   */\n  function ItemDragPlaceholder(item) {\n    this._item = item;\n    this._animate = new ItemAnimate();\n    this._element = null;\n    this._className = '';\n    this._didMigrate = false;\n    this._resetAfterLayout = false;\n    this._currentLeft = 0;\n    this._currentTop = 0;\n    this._nextLeft = 0;\n    this._nextTop = 0;\n\n    // Bind animation handlers.\n    this._setupAnimation = this._setupAnimation.bind(this);\n    this._startAnimation = this._startAnimation.bind(this);\n\n    // Bind event handlers.\n    this._onLayoutStart = this._onLayoutStart.bind(this);\n    this._onLayoutEnd = this._onLayoutEnd.bind(this);\n    this._onReleaseEnd = this._onReleaseEnd.bind(this);\n    this._onMigrate = this._onMigrate.bind(this);\n  }\n\n  /**\n   * Private prototype methods\n   * *************************\n   */\n\n  /**\n   * Move placeholder to a new position.\n   *\n   * @private\n   * @memberof ItemDragPlaceholder.prototype\n   */\n  ItemDragPlaceholder.prototype._onLayoutStart = function() {\n    var item = this._item;\n    var grid = item.getGrid();\n\n    // Find out the item's new (unapplied) left and top position.\n    var itemIndex = grid._items.indexOf(item);\n    var nextLeft = grid._layout.slots[itemIndex * 2];\n    var nextTop = grid._layout.slots[itemIndex * 2 + 1];\n\n    // If item's position did not change and the item did not migrate we can\n    // safely skip layout.\n    if (!this._didMigrate && item._left === nextLeft && item._top === nextTop) {\n      return;\n    }\n\n    // Slots data is calculated with item margins added to them so we need to add\n    // item's left and top margin to the slot data to get the placeholder's\n    // next position.\n    nextLeft += item._marginLeft;\n    nextTop += item._marginTop;\n\n    // Just snap to new position without any animations if no animation is\n    // required or if placeholder moves between grids.\n    var animEnabled = grid._settings.dragPlaceholder.duration > 0;\n    if (!animEnabled || this._didMigrate) {\n      // Cancel potential (queued) layout tick.\n      cancelPlaceholderTick(item._id);\n\n      // Snap placeholder to correct position.\n      var targetStyles = { transform: getTranslateString(nextLeft, nextTop) };\n      if (this._animate.isAnimating()) {\n        this._animate.stop(targetStyles);\n      } else {\n        setStyles(this._element, targetStyles);\n      }\n\n      // Move placeholder inside correct container after migration.\n      if (this._didMigrate) {\n        grid.getElement().appendChild(this._element);\n        this._didMigrate = false;\n      }\n\n      return;\n    }\n\n    // Start the placeholder's layout animation in the next tick. We do this to\n    // avoid layout thrashing.\n    this._nextLeft = nextLeft;\n    this._nextTop = nextTop;\n    addPlaceholderTick(item._id, this._setupAnimation, this._startAnimation);\n  };\n\n  /**\n   * Prepare placeholder for layout animation.\n   *\n   * @private\n   * @memberof ItemDragPlaceholder.prototype\n   */\n  ItemDragPlaceholder.prototype._setupAnimation = function() {\n    if (!this.isActive()) return;\n\n    var translate = getTranslate(this._element);\n    this._currentLeft = translate.x;\n    this._currentTop = translate.y;\n  };\n\n  /**\n   * Start layout animation.\n   *\n   * @private\n   * @memberof ItemDragPlaceholder.prototype\n   */\n  ItemDragPlaceholder.prototype._startAnimation = function() {\n    if (!this.isActive()) return;\n\n    var animation = this._animate;\n    var currentLeft = this._currentLeft;\n    var currentTop = this._currentTop;\n    var nextLeft = this._nextLeft;\n    var nextTop = this._nextTop;\n    var targetStyles = { transform: getTranslateString(nextLeft, nextTop) };\n\n    // If placeholder is already in correct position let's just stop animation\n    // and be done with it.\n    if (currentLeft === nextLeft && currentTop === nextTop) {\n      if (animation.isAnimating()) animation.stop(targetStyles);\n      return;\n    }\n\n    // Otherwise let's start the animation.\n    var settings = this._item.getGrid()._settings.dragPlaceholder;\n    var currentStyles = { transform: getTranslateString(currentLeft, currentTop) };\n    animation.start(currentStyles, targetStyles, {\n      duration: settings.duration,\n      easing: settings.easing,\n      onFinish: this._onLayoutEnd\n    });\n  };\n\n  /**\n   * Layout end handler.\n   *\n   * @private\n   * @memberof ItemDragPlaceholder.prototype\n   */\n  ItemDragPlaceholder.prototype._onLayoutEnd = function() {\n    if (this._resetAfterLayout) {\n      this.reset();\n    }\n  };\n\n  /**\n   * Drag end handler. This handler is called when dragReleaseEnd event is\n   * emitted and receives the event data as it's argument.\n   *\n   * @private\n   * @memberof ItemDragPlaceholder.prototype\n   * @param {Item} item\n   */\n  ItemDragPlaceholder.prototype._onReleaseEnd = function(item) {\n    if (item._id === this._item._id) {\n      // If the placeholder is not animating anymore we can safely reset it.\n      if (!this._animate.isAnimating()) {\n        this.reset();\n        return;\n      }\n\n      // If the placeholder item is still animating here, let's wait for it to\n      // finish it's animation.\n      this._resetAfterLayout = true;\n    }\n  };\n\n  /**\n   * Migration start handler. This handler is called when beforeSend event is\n   * emitted and receives the event data as it's argument.\n   *\n   * @private\n   * @memberof ItemDragPlaceholder.prototype\n   * @param {Object} data\n   * @param {Item} data.item\n   * @param {Grid} data.fromGrid\n   * @param {Number} data.fromIndex\n   * @param {Grid} data.toGrid\n   * @param {Number} data.toIndex\n   */\n  ItemDragPlaceholder.prototype._onMigrate = function(data) {\n    // Make sure we have a matching item.\n    if (data.item !== this._item) return;\n\n    var grid = this._item.getGrid();\n    var nextGrid = data.toGrid;\n\n    // Unbind listeners from current grid.\n    grid.off(eventDragReleaseEnd, this._onReleaseEnd);\n    grid.off(eventLayoutStart, this._onLayoutStart);\n    grid.off(eventBeforeSend, this._onMigrate);\n\n    // Bind listeners to the next grid.\n    nextGrid.on(eventDragReleaseEnd, this._onReleaseEnd);\n    nextGrid.on(eventLayoutStart, this._onLayoutStart);\n    nextGrid.on(eventBeforeSend, this._onMigrate);\n\n    // Mark the item as migrated.\n    this._didMigrate = true;\n  };\n\n  /**\n   * Public prototype methods\n   * ************************\n   */\n\n  /**\n   * Create placeholder. Note that this method only writes to DOM and does not\n   * read anything from DOM so it should not cause any additional layout\n   * thrashing when it's called at the end of the drag start procedure.\n   *\n   * @public\n   * @memberof ItemDragPlaceholder.prototype\n   */\n  ItemDragPlaceholder.prototype.create = function() {\n    // If we already have placeholder set up we can skip the initiation logic.\n    if (this.isActive()) {\n      this._resetAfterLayout = false;\n      return;\n    }\n\n    var item = this._item;\n    var grid = item.getGrid();\n    var settings = grid._settings;\n    var animation = this._animate;\n\n    // Create placeholder element.\n    var element;\n    if (isFunction(settings.dragPlaceholder.createElement)) {\n      element = settings.dragPlaceholder.createElement(item);\n    } else {\n      element = window.document.createElement('div');\n    }\n    this._element = element;\n\n    // Update element to animation instance.\n    animation._element = element;\n\n    // Add placeholder class to the placeholder element.\n    this._className = settings.itemPlaceholderClass || '';\n    if (this._className) {\n      addClass(element, this._className);\n    }\n\n    // Position the placeholder item correctly.\n    var left = item._left + item._marginLeft;\n    var top = item._top + item._marginTop;\n    setStyles(element, {\n      display: 'block',\n      position: 'absolute',\n      left: '0',\n      top: '0',\n      width: item._width + 'px',\n      height: item._height + 'px',\n      transform: getTranslateString(left, top)\n    });\n\n    // Bind event listeners.\n    grid.on(eventLayoutStart, this._onLayoutStart);\n    grid.on(eventDragReleaseEnd, this._onReleaseEnd);\n    grid.on(eventBeforeSend, this._onMigrate);\n\n    // onCreate hook.\n    if (isFunction(settings.dragPlaceholder.onCreate)) {\n      settings.dragPlaceholder.onCreate(item, element);\n    }\n\n    // Insert the placeholder element to the grid.\n    grid.getElement().appendChild(element);\n  };\n\n  /**\n   * Reset placeholder data.\n   *\n   * @public\n   * @memberof ItemDragPlaceholder.prototype\n   */\n  ItemDragPlaceholder.prototype.reset = function() {\n    if (!this.isActive()) return;\n\n    var element = this._element;\n    var item = this._item;\n    var grid = item.getGrid();\n    var settings = grid._settings;\n    var animation = this._animate;\n\n    // Reset flag.\n    this._resetAfterLayout = false;\n\n    // Cancel potential (queued) layout tick.\n    cancelPlaceholderTick(item._id);\n\n    // Reset animation instance.\n    animation.stop();\n    animation._element = null;\n\n    // Unbind event listeners.\n    grid.off(eventDragReleaseEnd, this._onReleaseEnd);\n    grid.off(eventLayoutStart, this._onLayoutStart);\n    grid.off(eventBeforeSend, this._onMigrate);\n\n    // Remove placeholder class from the placeholder element.\n    if (this._className) {\n      removeClass(element, this._className);\n      this._className = '';\n    }\n\n    // Remove element.\n    element.parentNode.removeChild(element);\n    this._element = null;\n\n    // onRemove hook. Note that here we use the current grid's onRemove callback\n    // so if the item has migrated during drag the onRemove method will not be\n    // the originating grid's method.\n    if (isFunction(settings.dragPlaceholder.onRemove)) {\n      settings.dragPlaceholder.onRemove(item, element);\n    }\n  };\n\n  /**\n   * Update placeholder's dimensions.\n   *\n   * @public\n   * @memberof ItemDragPlaceholder.prototype\n   * @param {Number} width\n   * @param {height} height\n   */\n  ItemDragPlaceholder.prototype.updateDimensions = function(width, height) {\n    if (this.isActive()) {\n      setStyles(this._element, {\n        width: width + 'px',\n        height: height + 'px'\n      });\n    }\n  };\n\n  /**\n   * Check if placeholder is currently active (visible).\n   *\n   * @public\n   * @memberof ItemDragPlaceholder.prototype\n   * @returns {Boolean}\n   */\n  ItemDragPlaceholder.prototype.isActive = function() {\n    return !!this._element;\n  };\n\n  /**\n   * Destroy placeholder instance.\n   *\n   * @public\n   * @memberof ItemDragPlaceholder.prototype\n   */\n  ItemDragPlaceholder.prototype.destroy = function() {\n    this.reset();\n    this._animate.destroy();\n    this._item = this._animate = null;\n  };\n\n  /**\n   * Queue constructor.\n   *\n   * @class\n   */\n  function Queue() {\n    this._queue = [];\n    this._isDestroyed = false;\n  }\n\n  /**\n   * Public prototype methods\n   * ************************\n   */\n\n  /**\n   * Add callback to the queue.\n   *\n   * @public\n   * @memberof Queue.prototype\n   * @param {Function} callback\n   * @returns {Queue}\n   */\n  Queue.prototype.add = function(callback) {\n    if (this._isDestroyed) return this;\n    this._queue.push(callback);\n    return this;\n  };\n\n  /**\n   * Process queue callbacks and reset the queue.\n   *\n   * @public\n   * @memberof Queue.prototype\n   * @param {*} arg1\n   * @param {*} arg2\n   * @returns {Queue}\n   */\n  Queue.prototype.flush = function(arg1, arg2) {\n    if (this._isDestroyed) return this;\n\n    var queue = this._queue;\n    var length = queue.length;\n    var i;\n\n    // Quit early if the queue is empty.\n    if (!length) return this;\n\n    var singleCallback = length === 1;\n    var snapshot = singleCallback ? queue[0] : queue.slice(0);\n\n    // Reset queue.\n    queue.length = 0;\n\n    // If we only have a single callback let's just call it.\n    if (singleCallback) {\n      snapshot(arg1, arg2);\n      return this;\n    }\n\n    // If we have multiple callbacks, let's process them.\n    for (i = 0; i < length; i++) {\n      snapshot[i](arg1, arg2);\n      if (this._isDestroyed) break;\n    }\n\n    return this;\n  };\n\n  /**\n   * Destroy Queue instance.\n   *\n   * @public\n   * @memberof Queue.prototype\n   * @returns {Queue}\n   */\n  Queue.prototype.destroy = function() {\n    if (this._isDestroyed) return this;\n\n    this._isDestroyed = true;\n    this._queue.length = 0;\n\n    return this;\n  };\n\n  /**\n   * Layout manager for Item instance.\n   *\n   * @class\n   * @param {Item} item\n   */\n  function ItemLayout(item) {\n    this._item = item;\n    this._isActive = false;\n    this._isDestroyed = false;\n    this._isInterrupted = false;\n    this._currentStyles = {};\n    this._targetStyles = {};\n    this._currentLeft = 0;\n    this._currentTop = 0;\n    this._offsetLeft = 0;\n    this._offsetTop = 0;\n    this._skipNextAnimation = false;\n    this._animateOptions = {\n      onFinish: this._finish.bind(this)\n    };\n    this._queue = new Queue();\n\n    // Bind animation handlers and finish method.\n    this._setupAnimation = this._setupAnimation.bind(this);\n    this._startAnimation = this._startAnimation.bind(this);\n  }\n\n  /**\n   * Public prototype methods\n   * ************************\n   */\n\n  /**\n   * Start item layout based on it's current data.\n   *\n   * @public\n   * @memberof ItemLayout.prototype\n   * @param {Boolean} [instant=false]\n   * @param {Function} [onFinish]\n   * @returns {ItemLayout}\n   */\n  ItemLayout.prototype.start = function(instant, onFinish) {\n    if (this._isDestroyed) return;\n\n    var item = this._item;\n    var element = item._element;\n    var release = item._release;\n    var gridSettings = item.getGrid()._settings;\n    var isPositioning = this._isActive;\n    var isJustReleased = release._isActive && release._isPositioningStarted === false;\n    var animDuration = isJustReleased\n      ? gridSettings.dragReleaseDuration\n      : gridSettings.layoutDuration;\n    var animEasing = isJustReleased ? gridSettings.dragReleaseEasing : gridSettings.layoutEasing;\n    var animEnabled = !instant && !this._skipNextAnimation && animDuration > 0;\n    var isAnimating;\n\n    // If the item is currently positioning process current layout callback\n    // queue with interrupted flag on.\n    if (isPositioning) this._queue.flush(true, item);\n\n    // Mark release positioning as started.\n    if (isJustReleased) release._isPositioningStarted = true;\n\n    // Push the callback to the callback queue.\n    if (isFunction(onFinish)) this._queue.add(onFinish);\n\n    // If no animations are needed, easy peasy!\n    if (!animEnabled) {\n      this._updateOffsets();\n      this._updateTargetStyles();\n      isAnimating = item._animate.isAnimating();\n      this.stop(false, this._targetStyles);\n      !isAnimating && setStyles(element, this._targetStyles);\n      this._skipNextAnimation = false;\n      return this._finish();\n    }\n\n    // Set item active and store some data for the animation that is about to be\n    // triggered.\n    this._isActive = true;\n    this._animateOptions.easing = animEasing;\n    this._animateOptions.duration = animDuration;\n    this._isInterrupted = isPositioning;\n\n    // Start the item's layout animation in the next tick.\n    addLayoutTick(item._id, this._setupAnimation, this._startAnimation);\n\n    return this;\n  };\n\n  /**\n   * Stop item's position animation if it is currently animating.\n   *\n   * @public\n   * @memberof ItemLayout.prototype\n   * @param {Boolean} [processCallbackQueue=false]\n   * @param {Object} [targetStyles]\n   * @returns {ItemLayout}\n   */\n  ItemLayout.prototype.stop = function(processCallbackQueue, targetStyles) {\n    if (this._isDestroyed || !this._isActive) return this;\n\n    var item = this._item;\n\n    // Cancel animation init.\n    cancelLayoutTick(item._id);\n\n    // Stop animation.\n    item._animate.stop(targetStyles);\n\n    // Remove positioning class.\n    removeClass(item._element, item.getGrid()._settings.itemPositioningClass);\n\n    // Reset active state.\n    this._isActive = false;\n\n    // Process callback queue if needed.\n    if (processCallbackQueue) this._queue.flush(true, item);\n\n    return this;\n  };\n\n  /**\n   * Destroy the instance and stop current animation if it is running.\n   *\n   * @public\n   * @memberof ItemLayout.prototype\n   * @returns {ItemLayout}\n   */\n  ItemLayout.prototype.destroy = function() {\n    if (this._isDestroyed) return this;\n    this.stop(true, {});\n    this._queue.destroy();\n    this._item = this._currentStyles = this._targetStyles = this._animateOptions = null;\n    this._isDestroyed = true;\n    return this;\n  };\n\n  /**\n   * Private prototype methods\n   * *************************\n   */\n\n  /**\n   * Calculate and update item's current layout offset data.\n   *\n   * @private\n   * @memberof ItemLayout.prototype\n   */\n  ItemLayout.prototype._updateOffsets = function() {\n    if (this._isDestroyed) return;\n\n    var item = this._item;\n    var migrate = item._migrate;\n    var release = item._release;\n\n    this._offsetLeft = release._isActive\n      ? release._containerDiffX\n      : migrate._isActive\n      ? migrate._containerDiffX\n      : 0;\n\n    this._offsetTop = release._isActive\n      ? release._containerDiffY\n      : migrate._isActive\n      ? migrate._containerDiffY\n      : 0;\n  };\n\n  /**\n   * Calculate and update item's layout target styles.\n   *\n   * @private\n   * @memberof ItemLayout.prototype\n   */\n  ItemLayout.prototype._updateTargetStyles = function() {\n    if (this._isDestroyed) return;\n    this._targetStyles.transform = getTranslateString(\n      this._item._left + this._offsetLeft,\n      this._item._top + this._offsetTop\n    );\n  };\n\n  /**\n   * Finish item layout procedure.\n   *\n   * @private\n   * @memberof ItemLayout.prototype\n   */\n  ItemLayout.prototype._finish = function() {\n    if (this._isDestroyed) return;\n\n    var item = this._item;\n    var migrate = item._migrate;\n    var release = item._release;\n\n    // Mark the item as inactive and remove positioning classes.\n    if (this._isActive) {\n      this._isActive = false;\n      removeClass(item._element, item.getGrid()._settings.itemPositioningClass);\n    }\n\n    // Finish up release and migration.\n    if (release._isActive) release.stop();\n    if (migrate._isActive) migrate.stop();\n\n    // Process the callback queue.\n    this._queue.flush(false, item);\n  };\n\n  /**\n   * Prepare item for layout animation.\n   *\n   * @private\n   * @memberof ItemLayout.prototype\n   */\n  ItemLayout.prototype._setupAnimation = function() {\n    var translate = getTranslate(this._item._element);\n    this._currentLeft = translate.x;\n    this._currentTop = translate.y;\n  };\n\n  /**\n   * Start layout animation.\n   *\n   * @private\n   * @memberof ItemLayout.prototype\n   */\n  ItemLayout.prototype._startAnimation = function() {\n    var item = this._item;\n    var settings = item.getGrid()._settings;\n\n    // Let's update the offset data and target styles.\n    this._updateOffsets();\n    this._updateTargetStyles();\n\n    // If the item is already in correct position let's quit early.\n    if (\n      item._left === this._currentLeft - this._offsetLeft &&\n      item._top === this._currentTop - this._offsetTop\n    ) {\n      if (this._isInterrupted) this.stop(false, this._targetStyles);\n      this._isActive = false;\n      this._finish();\n      return;\n    }\n\n    // Set item's positioning class if needed.\n    if (!this._isInterrupted) {\n      addClass(item._element, settings.itemPositioningClass);\n    }\n\n    // Get current styles for animation.\n    this._currentStyles.transform = getTranslateString(this._currentLeft, this._currentTop);\n\n    // Animate.\n    item._animate.start(this._currentStyles, this._targetStyles, this._animateOptions);\n  };\n\n  var tempStyles = {};\n\n  /**\n   * The migrate process handler constructor.\n   *\n   * @class\n   * @param {Item} item\n   */\n  function ItemMigrate(item) {\n    // Private props.\n    this._item = item;\n    this._isActive = false;\n    this._isDestroyed = false;\n    this._container = false;\n    this._containerDiffX = 0;\n    this._containerDiffY = 0;\n  }\n\n  /**\n   * Public prototype methods\n   * ************************\n   */\n\n  /**\n   * Start the migrate process of an item.\n   *\n   * @public\n   * @memberof ItemMigrate.prototype\n   * @param {Grid} targetGrid\n   * @param {GridSingleItemQuery} position\n   * @param {HTMLElement} [container]\n   * @returns {ItemMigrate}\n   */\n  ItemMigrate.prototype.start = function(targetGrid, position, container) {\n    if (this._isDestroyed) return this;\n\n    var item = this._item;\n    var element = item._element;\n    var isVisible = item.isVisible();\n    var grid = item.getGrid();\n    var settings = grid._settings;\n    var targetSettings = targetGrid._settings;\n    var targetElement = targetGrid._element;\n    var targetItems = targetGrid._items;\n    var currentIndex = grid._items.indexOf(item);\n    var targetContainer = container || window.document.body;\n    var targetIndex;\n    var targetItem;\n    var currentContainer;\n    var offsetDiff;\n    var containerDiff;\n    var translate;\n    var translateX;\n    var translateY;\n\n    // Get target index.\n    if (typeof position === 'number') {\n      targetIndex = normalizeArrayIndex(targetItems, position, true);\n    } else {\n      targetItem = targetGrid._getItem(position);\n      /** @todo Consider throwing an error here instead of silently failing. */\n      if (!targetItem) return this;\n      targetIndex = targetItems.indexOf(targetItem);\n    }\n\n    // Get current translateX and translateY values if needed.\n    if (item.isPositioning() || this._isActive || item.isReleasing()) {\n      translate = getTranslate(element);\n      translateX = translate.x;\n      translateY = translate.y;\n    }\n\n    // Abort current positioning.\n    if (item.isPositioning()) {\n      item._layout.stop(true, { transform: getTranslateString(translateX, translateY) });\n    }\n\n    // Abort current migration.\n    if (this._isActive) {\n      translateX -= this._containerDiffX;\n      translateY -= this._containerDiffY;\n      this.stop(true, { transform: getTranslateString(translateX, translateY) });\n    }\n\n    // Abort current release.\n    if (item.isReleasing()) {\n      translateX -= item._release._containerDiffX;\n      translateY -= item._release._containerDiffY;\n      item._release.stop(true, { transform: getTranslateString(translateX, translateY) });\n    }\n\n    // Stop current visibility animations.\n    item._visibility._stopAnimation();\n\n    // Destroy current drag.\n    if (item._drag) item._drag.destroy();\n\n    // Process current visibility animation queue.\n    item._visibility._queue.flush(true, item);\n\n    // Emit beforeSend event.\n    if (grid._hasListeners(eventBeforeSend)) {\n      grid._emit(eventBeforeSend, {\n        item: item,\n        fromGrid: grid,\n        fromIndex: currentIndex,\n        toGrid: targetGrid,\n        toIndex: targetIndex\n      });\n    }\n\n    // Emit beforeReceive event.\n    if (targetGrid._hasListeners(eventBeforeReceive)) {\n      targetGrid._emit(eventBeforeReceive, {\n        item: item,\n        fromGrid: grid,\n        fromIndex: currentIndex,\n        toGrid: targetGrid,\n        toIndex: targetIndex\n      });\n    }\n\n    // Remove current classnames.\n    removeClass(element, settings.itemClass);\n    removeClass(element, settings.itemVisibleClass);\n    removeClass(element, settings.itemHiddenClass);\n\n    // Add new classnames.\n    addClass(element, targetSettings.itemClass);\n    addClass(element, isVisible ? targetSettings.itemVisibleClass : targetSettings.itemHiddenClass);\n\n    // Move item instance from current grid to target grid.\n    grid._items.splice(currentIndex, 1);\n    arrayInsert(targetItems, item, targetIndex);\n\n    // Update item's grid id reference.\n    item._gridId = targetGrid._id;\n\n    // Get current container.\n    currentContainer = element.parentNode;\n\n    // Move the item inside the target container if it's different than the\n    // current container.\n    if (targetContainer !== currentContainer) {\n      targetContainer.appendChild(element);\n      offsetDiff = getOffsetDiff(targetContainer, currentContainer, true);\n      if (!translate) {\n        translate = getTranslate(element);\n        translateX = translate.x;\n        translateY = translate.y;\n      }\n      element.style[transformProp] = getTranslateString(\n        translateX + offsetDiff.left,\n        translateY + offsetDiff.top\n      );\n    }\n\n    // Update child element's styles to reflect the current visibility state.\n    item._child.removeAttribute('style');\n    setStyles(item._child, isVisible ? targetSettings.visibleStyles : targetSettings.hiddenStyles);\n\n    // Update display style.\n    element.style.display = isVisible ? 'block' : 'hidden';\n\n    // Get offset diff for the migration data.\n    containerDiff = getOffsetDiff(targetContainer, targetElement, true);\n\n    // Update item's cached dimensions and sort data.\n    item._refreshDimensions();\n    item._refreshSortData();\n\n    // Create new drag handler.\n    item._drag = targetSettings.dragEnabled ? new ItemDrag(item) : null;\n\n    // Setup migration data.\n    this._isActive = true;\n    this._container = targetContainer;\n    this._containerDiffX = containerDiff.left;\n    this._containerDiffY = containerDiff.top;\n\n    // Emit send event.\n    if (grid._hasListeners(eventSend)) {\n      grid._emit(eventSend, {\n        item: item,\n        fromGrid: grid,\n        fromIndex: currentIndex,\n        toGrid: targetGrid,\n        toIndex: targetIndex\n      });\n    }\n\n    // Emit receive event.\n    if (targetGrid._hasListeners(eventReceive)) {\n      targetGrid._emit(eventReceive, {\n        item: item,\n        fromGrid: grid,\n        fromIndex: currentIndex,\n        toGrid: targetGrid,\n        toIndex: targetIndex\n      });\n    }\n\n    return this;\n  };\n\n  /**\n   * End the migrate process of an item. This method can be used to abort an\n   * ongoing migrate process (animation) or finish the migrate process.\n   *\n   * @public\n   * @memberof ItemMigrate.prototype\n   * @param {Boolean} [abort=false]\n   *  - Should the migration be aborted?\n   * @param {Object} [currentStyles]\n   *  - Optional current translateX and translateY styles.\n   * @returns {ItemMigrate}\n   */\n  ItemMigrate.prototype.stop = function(abort, currentStyles) {\n    if (this._isDestroyed || !this._isActive) return this;\n\n    var item = this._item;\n    var element = item._element;\n    var grid = item.getGrid();\n    var gridElement = grid._element;\n    var translate;\n\n    if (this._container !== gridElement) {\n      if (!currentStyles) {\n        if (abort) {\n          translate = getTranslate(element);\n          tempStyles.transform = getTranslateString(\n            translate.x - this._containerDiffX,\n            translate.y - this._containerDiffY\n          );\n        } else {\n          tempStyles.transform = getTranslateString(item._left, item._top);\n        }\n        currentStyles = tempStyles;\n      }\n      gridElement.appendChild(element);\n      setStyles(element, currentStyles);\n    }\n\n    this._isActive = false;\n    this._container = null;\n    this._containerDiffX = 0;\n    this._containerDiffY = 0;\n\n    return this;\n  };\n\n  /**\n   * Destroy instance.\n   *\n   * @public\n   * @memberof ItemMigrate.prototype\n   * @returns {ItemMigrate}\n   */\n  ItemMigrate.prototype.destroy = function() {\n    if (this._isDestroyed) return this;\n    this.stop(true);\n    this._item = null;\n    this._isDestroyed = true;\n    return this;\n  };\n\n  var tempStyles$1 = {};\n\n  /**\n   * The release process handler constructor. Although this might seem as proper\n   * fit for the drag process this needs to be separated into it's own logic\n   * because there might be a scenario where drag is disabled, but the release\n   * process still needs to be implemented (dragging from a grid to another).\n   *\n   * @class\n   * @param {Item} item\n   */\n  function ItemRelease(item) {\n    this._item = item;\n    this._isActive = false;\n    this._isDestroyed = false;\n    this._isPositioningStarted = false;\n    this._containerDiffX = 0;\n    this._containerDiffY = 0;\n  }\n\n  /**\n   * Public prototype methods\n   * ************************\n   */\n\n  /**\n   * Start the release process of an item.\n   *\n   * @public\n   * @memberof ItemRelease.prototype\n   * @returns {ItemRelease}\n   */\n  ItemRelease.prototype.start = function() {\n    if (this._isDestroyed || this._isActive) return this;\n\n    var item = this._item;\n    var grid = item.getGrid();\n\n    // Flag release as active.\n    this._isActive = true;\n\n    // Add release class name to the released element.\n    addClass(item._element, grid._settings.itemReleasingClass);\n\n    // Emit dragReleaseStart event.\n    grid._emit(eventDragReleaseStart, item);\n\n    // Position the released item.\n    item._layout.start(false);\n\n    return this;\n  };\n\n  /**\n   * End the release process of an item. This method can be used to abort an\n   * ongoing release process (animation) or finish the release process.\n   *\n   * @public\n   * @memberof ItemRelease.prototype\n   * @param {Boolean} [abort=false]\n   *  - Should the release be aborted? When true, the release end event won't be\n   *    emitted. Set to true only when you need to abort the release process\n   *    while the item is animating to it's position.\n   * @param {Object} [currentStyles]\n   *  - Optional current translateX and translateY styles.\n   * @returns {ItemRelease}\n   */\n  ItemRelease.prototype.stop = function(abort, currentStyles) {\n    if (this._isDestroyed || !this._isActive) return this;\n\n    var item = this._item;\n    var element = item._element;\n    var grid = item.getGrid();\n    var container = grid._element;\n    var translate;\n\n    // Reset data and remove releasing class name from the element.\n    this._reset();\n\n    // If the released element is outside the grid's container element put it\n    // back there and adjust position accordingly.\n    if (element.parentNode !== container) {\n      if (!currentStyles) {\n        if (abort) {\n          translate = getTranslate(element);\n          tempStyles$1.transform = getTranslateString(\n            translate.x - this._containerDiffX,\n            translate.y - this._containerDiffY\n          );\n        } else {\n          tempStyles$1.transform = getTranslateString(item._left, item._top);\n        }\n        currentStyles = tempStyles$1;\n      }\n      container.appendChild(element);\n      setStyles(element, currentStyles);\n    }\n\n    // Emit dragReleaseEnd event.\n    if (!abort) grid._emit(eventDragReleaseEnd, item);\n\n    return this;\n  };\n\n  /**\n   * Destroy instance.\n   *\n   * @public\n   * @memberof ItemRelease.prototype\n   * @returns {ItemRelease}\n   */\n  ItemRelease.prototype.destroy = function() {\n    if (this._isDestroyed) return this;\n    this.stop(true);\n    this._item = null;\n    this._isDestroyed = true;\n    return this;\n  };\n\n  /**\n   * Private prototype methods\n   * *************************\n   */\n\n  /**\n   * Reset public data and remove releasing class.\n   *\n   * @private\n   * @memberof ItemRelease.prototype\n   */\n  ItemRelease.prototype._reset = function() {\n    if (this._isDestroyed) return;\n    var item = this._item;\n    this._isActive = false;\n    this._isPositioningStarted = false;\n    this._containerDiffX = 0;\n    this._containerDiffY = 0;\n    removeClass(item._element, item.getGrid()._settings.itemReleasingClass);\n  };\n\n  /**\n   * Get current values of the provided styles definition object.\n   *\n   * @param {HTMLElement} element\n   * @param {Object} styles\n   * @return {Object}\n   */\n  function getCurrentStyles(element, styles) {\n    var current = {};\n    for (var prop in styles) {\n      current[prop] = getStyle(element, getStyleName(prop));\n    }\n    return current;\n  }\n\n  /**\n   * Visibility manager for Item instance.\n   *\n   * @class\n   * @param {Item} item\n   */\n  function ItemVisibility(item) {\n    var isActive = item._isActive;\n    var element = item._element;\n    var settings = item.getGrid()._settings;\n\n    this._item = item;\n    this._isDestroyed = false;\n\n    // Set up visibility states.\n    this._isHidden = !isActive;\n    this._isHiding = false;\n    this._isShowing = false;\n\n    // Callback queue.\n    this._queue = new Queue();\n\n    // Bind show/hide finishers.\n    this._finishShow = this._finishShow.bind(this);\n    this._finishHide = this._finishHide.bind(this);\n\n    // Force item to be either visible or hidden on init.\n    element.style.display = isActive ? 'block' : 'none';\n\n    // Set visible/hidden class.\n    addClass(element, isActive ? settings.itemVisibleClass : settings.itemHiddenClass);\n\n    // Set initial styles for the child element.\n    setStyles(item._child, isActive ? settings.visibleStyles : settings.hiddenStyles);\n  }\n\n  /**\n   * Public prototype methods\n   * ************************\n   */\n\n  /**\n   * Show item.\n   *\n   * @public\n   * @memberof ItemVisibility.prototype\n   * @param {Boolean} instant\n   * @param {Function} [onFinish]\n   * @returns {ItemVisibility}\n   */\n  ItemVisibility.prototype.show = function(instant, onFinish) {\n    if (this._isDestroyed) return this;\n\n    var item = this._item;\n    var element = item._element;\n    var queue = this._queue;\n    var callback = isFunction(onFinish) ? onFinish : null;\n    var grid = item.getGrid();\n    var settings = grid._settings;\n\n    // If item is visible call the callback and be done with it.\n    if (!this._isShowing && !this._isHidden) {\n      callback && callback(false, item);\n      return this;\n    }\n\n    // If item is showing and does not need to be shown instantly, let's just\n    // push callback to the callback queue and be done with it.\n    if (this._isShowing && !instant) {\n      callback && queue.add(callback);\n      return this;\n    }\n\n    // If the item is hiding or hidden process the current visibility callback\n    // queue with the interrupted flag active, update classes and set display\n    // to block if necessary.\n    if (!this._isShowing) {\n      queue.flush(true, item);\n      removeClass(element, settings.itemHiddenClass);\n      addClass(element, settings.itemVisibleClass);\n      if (!this._isHiding) element.style.display = 'block';\n    }\n\n    // Push callback to the callback queue.\n    callback && queue.add(callback);\n\n    // Update visibility states.\n    item._isActive = this._isShowing = true;\n    this._isHiding = this._isHidden = false;\n\n    // Finally let's start show animation.\n    this._startAnimation(true, instant, this._finishShow);\n\n    return this;\n  };\n\n  /**\n   * Hide item.\n   *\n   * @public\n   * @memberof ItemVisibility.prototype\n   * @param {Boolean} instant\n   * @param {Function} [onFinish]\n   * @returns {ItemVisibility}\n   */\n  ItemVisibility.prototype.hide = function(instant, onFinish) {\n    if (this._isDestroyed) return this;\n\n    var item = this._item;\n    var element = item._element;\n    var queue = this._queue;\n    var callback = isFunction(onFinish) ? onFinish : null;\n    var grid = item.getGrid();\n    var settings = grid._settings;\n\n    // If item is already hidden call the callback and be done with it.\n    if (!this._isHiding && this._isHidden) {\n      callback && callback(false, item);\n      return this;\n    }\n\n    // If item is hiding and does not need to be hidden instantly, let's just\n    // push callback to the callback queue and be done with it.\n    if (this._isHiding && !instant) {\n      callback && queue.add(callback);\n      return this;\n    }\n\n    // If the item is showing or visible process the current visibility callback\n    // queue with the interrupted flag active, update classes and set display\n    // to block if necessary.\n    if (!this._isHiding) {\n      queue.flush(true, item);\n      addClass(element, settings.itemHiddenClass);\n      removeClass(element, settings.itemVisibleClass);\n    }\n\n    // Push callback to the callback queue.\n    callback && queue.add(callback);\n\n    // Update visibility states.\n    this._isHidden = this._isHiding = true;\n    item._isActive = this._isShowing = false;\n\n    // Finally let's start hide animation.\n    this._startAnimation(false, instant, this._finishHide);\n\n    return this;\n  };\n\n  /**\n   * Destroy the instance and stop current animation if it is running.\n   *\n   * @public\n   * @memberof ItemVisibility.prototype\n   * @returns {ItemVisibility}\n   */\n  ItemVisibility.prototype.destroy = function() {\n    if (this._isDestroyed) return this;\n\n    var item = this._item;\n    var element = item._element;\n    var grid = item.getGrid();\n    var queue = this._queue;\n    var settings = grid._settings;\n\n    // Stop visibility animation.\n    this._stopAnimation({});\n\n    // Fire all uncompleted callbacks with interrupted flag and destroy the queue.\n    queue.flush(true, item).destroy();\n\n    // Remove visible/hidden classes.\n    removeClass(element, settings.itemVisibleClass);\n    removeClass(element, settings.itemHiddenClass);\n\n    // Reset state.\n    this._item = null;\n    this._isHiding = this._isShowing = false;\n    this._isDestroyed = this._isHidden = true;\n\n    return this;\n  };\n\n  /**\n   * Private prototype methods\n   * *************************\n   */\n\n  /**\n   * Start visibility animation.\n   *\n   * @private\n   * @memberof ItemVisibility.prototype\n   * @param {Boolean} toVisible\n   * @param {Boolean} [instant]\n   * @param {Function} [onFinish]\n   */\n  ItemVisibility.prototype._startAnimation = function(toVisible, instant, onFinish) {\n    if (this._isDestroyed) return;\n\n    var item = this._item;\n    var settings = item.getGrid()._settings;\n    var targetStyles = toVisible ? settings.visibleStyles : settings.hiddenStyles;\n    var duration = parseInt(toVisible ? settings.showDuration : settings.hideDuration) || 0;\n    var easing = (toVisible ? settings.showEasing : settings.hideEasing) || 'ease';\n    var isInstant = instant || duration <= 0;\n    var currentStyles;\n\n    // No target styles? Let's quit early.\n    if (!targetStyles) {\n      onFinish && onFinish();\n      return;\n    }\n\n    // Cancel queued visibility tick.\n    cancelVisibilityTick(item._id);\n\n    // If we need to apply the styles instantly without animation.\n    if (isInstant) {\n      if (item._animateChild.isAnimating()) {\n        item._animateChild.stop(targetStyles);\n      } else {\n        setStyles(item._child, targetStyles);\n      }\n      onFinish && onFinish();\n      return;\n    }\n\n    // Start the animation in the next tick (to avoid layout thrashing).\n    addVisibilityTick(\n      item._id,\n      function() {\n        currentStyles = getCurrentStyles(item._child, targetStyles);\n      },\n      function() {\n        item._animateChild.start(currentStyles, targetStyles, {\n          duration: duration,\n          easing: easing,\n          onFinish: onFinish\n        });\n      }\n    );\n  };\n\n  /**\n   * Stop visibility animation.\n   *\n   * @private\n   * @memberof ItemVisibility.prototype\n   * @param {Object} [targetStyles]\n   */\n  ItemVisibility.prototype._stopAnimation = function(targetStyles) {\n    if (this._isDestroyed) return;\n    var item = this._item;\n    cancelVisibilityTick(item._id);\n    item._animateChild.stop(targetStyles);\n  };\n\n  /**\n   * Finish show procedure.\n   *\n   * @private\n   * @memberof ItemVisibility.prototype\n   */\n  ItemVisibility.prototype._finishShow = function() {\n    if (this._isHidden) return;\n    this._isShowing = false;\n    this._queue.flush(false, this._item);\n  };\n\n  /**\n   * Finish hide procedure.\n   *\n   * @private\n   * @memberof ItemVisibility.prototype\n   */\n  var finishStyles = {};\n  ItemVisibility.prototype._finishHide = function() {\n    if (!this._isHidden) return;\n    var item = this._item;\n    this._isHiding = false;\n    finishStyles.transform = getTranslateString(0, 0);\n    item._layout.stop(true, finishStyles);\n    item._element.style.display = 'none';\n    this._queue.flush(false, item);\n  };\n\n  var id = 0;\n\n  /**\n   * Returns a unique numeric id (increments a base value on every call).\n   * @returns {Number}\n   */\n  function createUid() {\n    return ++id;\n  }\n\n  /**\n   * Creates a new Item instance for a Grid instance.\n   *\n   * @class\n   * @param {Grid} grid\n   * @param {HTMLElement} element\n   * @param {Boolean} [isActive]\n   */\n  function Item(grid, element, isActive) {\n    var settings = grid._settings;\n\n    // Create instance id.\n    this._id = createUid();\n\n    // Reference to connected Grid instance's id.\n    this._gridId = grid._id;\n\n    // Destroyed flag.\n    this._isDestroyed = false;\n\n    // Set up initial positions.\n    this._left = 0;\n    this._top = 0;\n\n    // The elements.\n    this._element = element;\n    this._child = element.children[0];\n\n    // If the provided item element is not a direct child of the grid container\n    // element, append it to the grid container.\n    if (element.parentNode !== grid._element) {\n      grid._element.appendChild(element);\n    }\n\n    // Set item class.\n    addClass(element, settings.itemClass);\n\n    // If isActive is not defined, let's try to auto-detect it.\n    if (typeof isActive !== 'boolean') {\n      isActive = getStyle(element, 'display') !== 'none';\n    }\n\n    // Set up active state (defines if the item is considered part of the layout\n    // or not).\n    this._isActive = isActive;\n\n    // Set element's initial position styles.\n    element.style.left = '0';\n    element.style.top = '0';\n    element.style[transformProp] = getTranslateString(0, 0);\n\n    // Initiate item's animation controllers.\n    this._animate = new ItemAnimate(element);\n    this._animateChild = new ItemAnimate(this._child);\n\n    // Setup visibility handler.\n    this._visibility = new ItemVisibility(this);\n\n    // Set up layout handler.\n    this._layout = new ItemLayout(this);\n\n    // Set up migration handler data.\n    this._migrate = new ItemMigrate(this);\n\n    // Set up release handler. Note that although this is fully linked to dragging\n    // this still needs to be always instantiated to handle migration scenarios\n    // correctly.\n    this._release = new ItemRelease(this);\n\n    // Set up drag placeholder handler. Note that although this is fully linked to\n    // dragging this still needs to be always instantiated to handle migration\n    // scenarios correctly.\n    this._dragPlaceholder = new ItemDragPlaceholder(this);\n\n    // Set up drag handler.\n    this._drag = settings.dragEnabled ? new ItemDrag(this) : null;\n\n    // Set up the initial dimensions and sort data.\n    this._refreshDimensions();\n    this._refreshSortData();\n  }\n\n  /**\n   * Public prototype methods\n   * ************************\n   */\n\n  /**\n   * Get the instance grid reference.\n   *\n   * @public\n   * @memberof Item.prototype\n   * @returns {Grid}\n   */\n  Item.prototype.getGrid = function() {\n    return gridInstances[this._gridId];\n  };\n\n  /**\n   * Get the instance element.\n   *\n   * @public\n   * @memberof Item.prototype\n   * @returns {HTMLElement}\n   */\n  Item.prototype.getElement = function() {\n    return this._element;\n  };\n\n  /**\n   * Get instance element's cached width.\n   *\n   * @public\n   * @memberof Item.prototype\n   * @returns {Number}\n   */\n  Item.prototype.getWidth = function() {\n    return this._width;\n  };\n\n  /**\n   * Get instance element's cached height.\n   *\n   * @public\n   * @memberof Item.prototype\n   * @returns {Number}\n   */\n  Item.prototype.getHeight = function() {\n    return this._height;\n  };\n\n  /**\n   * Get instance element's cached margins.\n   *\n   * @public\n   * @memberof Item.prototype\n   * @returns {Object}\n   *   - The returned object contains left, right, top and bottom properties\n   *     which indicate the item element's cached margins.\n   */\n  Item.prototype.getMargin = function() {\n    return {\n      left: this._marginLeft,\n      right: this._marginRight,\n      top: this._marginTop,\n      bottom: this._marginBottom\n    };\n  };\n\n  /**\n   * Get instance element's cached position.\n   *\n   * @public\n   * @memberof Item.prototype\n   * @returns {Object}\n   *   - The returned object contains left and top properties which indicate the\n   *     item element's cached position in the grid.\n   */\n  Item.prototype.getPosition = function() {\n    return {\n      left: this._left,\n      top: this._top\n    };\n  };\n\n  /**\n   * Is the item active?\n   *\n   * @public\n   * @memberof Item.prototype\n   * @returns {Boolean}\n   */\n  Item.prototype.isActive = function() {\n    return this._isActive;\n  };\n\n  /**\n   * Is the item visible?\n   *\n   * @public\n   * @memberof Item.prototype\n   * @returns {Boolean}\n   */\n  Item.prototype.isVisible = function() {\n    return !!this._visibility && !this._visibility._isHidden;\n  };\n\n  /**\n   * Is the item being animated to visible?\n   *\n   * @public\n   * @memberof Item.prototype\n   * @returns {Boolean}\n   */\n  Item.prototype.isShowing = function() {\n    return !!(this._visibility && this._visibility._isShowing);\n  };\n\n  /**\n   * Is the item being animated to hidden?\n   *\n   * @public\n   * @memberof Item.prototype\n   * @returns {Boolean}\n   */\n  Item.prototype.isHiding = function() {\n    return !!(this._visibility && this._visibility._isHiding);\n  };\n\n  /**\n   * Is the item positioning?\n   *\n   * @public\n   * @memberof Item.prototype\n   * @returns {Boolean}\n   */\n  Item.prototype.isPositioning = function() {\n    return !!(this._layout && this._layout._isActive);\n  };\n\n  /**\n   * Is the item being dragged?\n   *\n   * @public\n   * @memberof Item.prototype\n   * @returns {Boolean}\n   */\n  Item.prototype.isDragging = function() {\n    return !!(this._drag && this._drag._isActive);\n  };\n\n  /**\n   * Is the item being released?\n   *\n   * @public\n   * @memberof Item.prototype\n   * @returns {Boolean}\n   */\n  Item.prototype.isReleasing = function() {\n    return !!(this._release && this._release._isActive);\n  };\n\n  /**\n   * Is the item destroyed?\n   *\n   * @public\n   * @memberof Item.prototype\n   * @returns {Boolean}\n   */\n  Item.prototype.isDestroyed = function() {\n    return this._isDestroyed;\n  };\n\n  /**\n   * Private prototype methods\n   * *************************\n   */\n\n  /**\n   * Recalculate item's dimensions.\n   *\n   * @private\n   * @memberof Item.prototype\n   */\n  Item.prototype._refreshDimensions = function() {\n    if (this._isDestroyed || this._visibility._isHidden) return;\n\n    var element = this._element;\n    var dragPlaceholder = this._dragPlaceholder;\n    var rect = element.getBoundingClientRect();\n\n    // Calculate width and height.\n    this._width = rect.width;\n    this._height = rect.height;\n\n    // Calculate margins (ignore negative margins).\n    this._marginLeft = Math.max(0, getStyleAsFloat(element, 'margin-left'));\n    this._marginRight = Math.max(0, getStyleAsFloat(element, 'margin-right'));\n    this._marginTop = Math.max(0, getStyleAsFloat(element, 'margin-top'));\n    this._marginBottom = Math.max(0, getStyleAsFloat(element, 'margin-bottom'));\n\n    // Keep drag placeholder's dimensions synced with the item's.\n    if (dragPlaceholder) {\n      dragPlaceholder.updateDimensions(this._width, this._height);\n    }\n  };\n\n  /**\n   * Fetch and store item's sort data.\n   *\n   * @private\n   * @memberof Item.prototype\n   */\n  Item.prototype._refreshSortData = function() {\n    if (this._isDestroyed) return;\n\n    var data = (this._sortData = {});\n    var getters = this.getGrid()._settings.sortData;\n    var prop;\n\n    for (prop in getters) {\n      data[prop] = getters[prop](this, this._element);\n    }\n  };\n\n  /**\n   * Destroy item instance.\n   *\n   * @private\n   * @memberof Item.prototype\n   * @param {Boolean} [removeElement=false]\n   */\n  Item.prototype._destroy = function(removeElement) {\n    if (this._isDestroyed) return;\n\n    var element = this._element;\n    var grid = this.getGrid();\n    var settings = grid._settings;\n    var index = grid._items.indexOf(this);\n\n    // Destroy handlers.\n    this._release.destroy();\n    this._migrate.destroy();\n    this._layout.destroy();\n    this._visibility.destroy();\n    this._animate.destroy();\n    this._animateChild.destroy();\n    this._dragPlaceholder.destroy();\n    this._drag && this._drag.destroy();\n\n    // Remove all inline styles.\n    element.removeAttribute('style');\n    this._child.removeAttribute('style');\n\n    // Remove item class.\n    removeClass(element, settings.itemClass);\n\n    // Remove item from Grid instance if it still exists there.\n    index > -1 && grid._items.splice(index, 1);\n\n    // Remove element from DOM.\n    removeElement && element.parentNode.removeChild(element);\n\n    // Reset state.\n    this._isActive = false;\n    this._isDestroyed = true;\n  };\n\n  /**\n   * This is the default layout algorithm for Muuri. Based on MAXRECTS approach\n   * as described by Jukka Jylänki in his survey: \"A Thousand Ways to Pack the\n   * Bin - A Practical Approach to Two-Dimensional Rectangle Bin Packing.\".\n   *\n   * @class\n   */\n  function Packer() {\n    this._slots = [];\n    this._slotSizes = [];\n    this._freeSlots = [];\n    this._newSlots = [];\n    this._rectItem = {};\n    this._rectStore = [];\n    this._rectId = 0;\n\n    // The layout return data, which will be populated in getLayout.\n    this._layout = {\n      slots: null,\n      setWidth: false,\n      setHeight: false,\n      width: false,\n      height: false\n    };\n\n    // Bind sort handlers.\n    this._sortRectsLeftTop = this._sortRectsLeftTop.bind(this);\n    this._sortRectsTopLeft = this._sortRectsTopLeft.bind(this);\n  }\n\n  /**\n   * @public\n   * @memberof Packer.prototype\n   * @param {Item[]} items\n   * @param {Number} width\n   * @param {Number} height\n   * @param {Number[]} [slots]\n   * @param {Object} [options]\n   * @param {Boolean} [options.fillGaps=false]\n   * @param {Boolean} [options.horizontal=false]\n   * @param {Boolean} [options.alignRight=false]\n   * @param {Boolean} [options.alignBottom=false]\n   * @returns {LayoutData}\n   */\n  Packer.prototype.getLayout = function(items, width, height, slots, options) {\n    var layout = this._layout;\n    var fillGaps = !!(options && options.fillGaps);\n    var isHorizontal = !!(options && options.horizontal);\n    var alignRight = !!(options && options.alignRight);\n    var alignBottom = !!(options && options.alignBottom);\n    var rounding = !!(options && options.rounding);\n    var slotSizes = this._slotSizes;\n    var i;\n\n    // Reset layout data.\n    layout.slots = slots ? slots : this._slots;\n    layout.width = isHorizontal ? 0 : rounding ? Math.round(width) : width;\n    layout.height = !isHorizontal ? 0 : rounding ? Math.round(height) : height;\n    layout.setWidth = isHorizontal;\n    layout.setHeight = !isHorizontal;\n\n    // Make sure slots and slot size arrays are reset.\n    layout.slots.length = 0;\n    slotSizes.length = 0;\n\n    // No need to go further if items do not exist.\n    if (!items.length) return layout;\n\n    // Find slots for items.\n    for (i = 0; i < items.length; i++) {\n      this._addSlot(items[i], isHorizontal, fillGaps, rounding, alignRight || alignBottom);\n    }\n\n    // If the alignment is set to right we need to adjust the results.\n    if (alignRight) {\n      for (i = 0; i < layout.slots.length; i = i + 2) {\n        layout.slots[i] = layout.width - (layout.slots[i] + slotSizes[i]);\n      }\n    }\n\n    // If the alignment is set to bottom we need to adjust the results.\n    if (alignBottom) {\n      for (i = 1; i < layout.slots.length; i = i + 2) {\n        layout.slots[i] = layout.height - (layout.slots[i] + slotSizes[i]);\n      }\n    }\n\n    // Reset slots arrays and rect id.\n    slotSizes.length = 0;\n    this._freeSlots.length = 0;\n    this._newSlots.length = 0;\n    this._rectId = 0;\n\n    return layout;\n  };\n\n  /**\n   * Calculate position for the layout item. Returns the left and top position\n   * of the item in pixels.\n   *\n   * @private\n   * @memberof Packer.prototype\n   * @param {Item} item\n   * @param {Boolean} isHorizontal\n   * @param {Boolean} fillGaps\n   * @param {Boolean} rounding\n   * @returns {Array}\n   */\n  Packer.prototype._addSlot = (function() {\n    var eps = 0.001;\n    var itemSlot = {};\n    return function(item, isHorizontal, fillGaps, rounding, trackSize) {\n      var layout = this._layout;\n      var freeSlots = this._freeSlots;\n      var newSlots = this._newSlots;\n      var rect;\n      var rectId;\n      var potentialSlots;\n      var ignoreCurrentSlots;\n      var i;\n      var ii;\n\n      // Reset new slots.\n      newSlots.length = 0;\n\n      // Set item slot initial data.\n      itemSlot.left = null;\n      itemSlot.top = null;\n      itemSlot.width = item._width + item._marginLeft + item._marginRight;\n      itemSlot.height = item._height + item._marginTop + item._marginBottom;\n\n      // Round item slot width and height if needed.\n      if (rounding) {\n        itemSlot.width = Math.round(itemSlot.width);\n        itemSlot.height = Math.round(itemSlot.height);\n      }\n\n      // Try to find a slot for the item.\n      for (i = 0; i < freeSlots.length; i++) {\n        rectId = freeSlots[i];\n        if (!rectId) continue;\n        rect = this._getRect(rectId);\n        if (itemSlot.width <= rect.width + eps && itemSlot.height <= rect.height + eps) {\n          itemSlot.left = rect.left;\n          itemSlot.top = rect.top;\n          break;\n        }\n      }\n\n      // If no slot was found for the item.\n      if (itemSlot.left === null) {\n        // Position the item in to the bottom left (vertical mode) or top right\n        // (horizontal mode) of the grid.\n        itemSlot.left = !isHorizontal ? 0 : layout.width;\n        itemSlot.top = !isHorizontal ? layout.height : 0;\n\n        // If gaps don't need filling do not add any current slots to the new\n        // slots array.\n        if (!fillGaps) {\n          ignoreCurrentSlots = true;\n        }\n      }\n\n      // In vertical mode, if the item's bottom overlaps the grid's bottom.\n      if (!isHorizontal && itemSlot.top + itemSlot.height > layout.height) {\n        // If item is not aligned to the left edge, create a new slot.\n        if (itemSlot.left > 0) {\n          newSlots.push(this._addRect(0, layout.height, itemSlot.left, Infinity));\n        }\n\n        // If item is not aligned to the right edge, create a new slot.\n        if (itemSlot.left + itemSlot.width < layout.width) {\n          newSlots.push(\n            this._addRect(\n              itemSlot.left + itemSlot.width,\n              layout.height,\n              layout.width - itemSlot.left - itemSlot.width,\n              Infinity\n            )\n          );\n        }\n\n        // Update grid height.\n        layout.height = itemSlot.top + itemSlot.height;\n      }\n\n      // In horizontal mode, if the item's right overlaps the grid's right edge.\n      if (isHorizontal && itemSlot.left + itemSlot.width > layout.width) {\n        // If item is not aligned to the top, create a new slot.\n        if (itemSlot.top > 0) {\n          newSlots.push(this._addRect(layout.width, 0, Infinity, itemSlot.top));\n        }\n\n        // If item is not aligned to the bottom, create a new slot.\n        if (itemSlot.top + itemSlot.height < layout.height) {\n          newSlots.push(\n            this._addRect(\n              layout.width,\n              itemSlot.top + itemSlot.height,\n              Infinity,\n              layout.height - itemSlot.top - itemSlot.height\n            )\n          );\n        }\n\n        // Update grid width.\n        layout.width = itemSlot.left + itemSlot.width;\n      }\n\n      // Clean up the current slots making sure there are no old slots that\n      // overlap with the item. If an old slot overlaps with the item, split it\n      // into smaller slots if necessary.\n      for (i = fillGaps ? 0 : ignoreCurrentSlots ? freeSlots.length : i; i < freeSlots.length; i++) {\n        rectId = freeSlots[i];\n        if (!rectId) continue;\n        rect = this._getRect(rectId);\n        potentialSlots = this._splitRect(rect, itemSlot);\n        for (ii = 0; ii < potentialSlots.length; ii++) {\n          rectId = potentialSlots[ii];\n          rect = this._getRect(rectId);\n          // Let's make sure here that we have a big enough slot\n          // (width/height > 0.49px) and also let's make sure that the slot is\n          // within the boundaries of the grid.\n          if (\n            rect.width > 0.49 &&\n            rect.height > 0.49 &&\n            ((!isHorizontal && rect.top < layout.height) ||\n              (isHorizontal && rect.left < layout.width))\n          ) {\n            newSlots.push(rectId);\n          }\n        }\n      }\n\n      // Sanitize new slots.\n      if (newSlots.length) {\n        this._purgeRects(newSlots).sort(\n          isHorizontal ? this._sortRectsLeftTop : this._sortRectsTopLeft\n        );\n      }\n\n      // Update layout width/height.\n      if (isHorizontal) {\n        layout.width = Math.max(layout.width, itemSlot.left + itemSlot.width);\n      } else {\n        layout.height = Math.max(layout.height, itemSlot.top + itemSlot.height);\n      }\n\n      // Add item slot data to layout slots (and store the slot size for later\n      // usage too if necessary).\n      layout.slots.push(itemSlot.left, itemSlot.top);\n      if (trackSize) this._slotSizes.push(itemSlot.width, itemSlot.height);\n\n      // Free/new slots switcheroo!\n      this._freeSlots = newSlots;\n      this._newSlots = freeSlots;\n    };\n  })();\n\n  /**\n   * Add a new rectangle to the rectangle store. Returns the id of the new\n   * rectangle.\n   *\n   * @private\n   * @memberof Packer.prototype\n   * @param {Number} left\n   * @param {Number} top\n   * @param {Number} width\n   * @param {Number} height\n   * @returns {RectId}\n   */\n  Packer.prototype._addRect = function(left, top, width, height) {\n    var rectId = ++this._rectId;\n    var rectStore = this._rectStore;\n\n    rectStore[rectId] = left || 0;\n    rectStore[++this._rectId] = top || 0;\n    rectStore[++this._rectId] = width || 0;\n    rectStore[++this._rectId] = height || 0;\n\n    return rectId;\n  };\n\n  /**\n   * Get rectangle data from the rectangle store by id. Optionally you can\n   * provide a target object where the rectangle data will be written in. By\n   * default an internal object is reused as a target object.\n   *\n   * @private\n   * @memberof Packer.prototype\n   * @param {RectId} id\n   * @param {Object} [target]\n   * @returns {Object}\n   */\n  Packer.prototype._getRect = function(id, target) {\n    var rectItem = target ? target : this._rectItem;\n    var rectStore = this._rectStore;\n\n    rectItem.left = rectStore[id] || 0;\n    rectItem.top = rectStore[++id] || 0;\n    rectItem.width = rectStore[++id] || 0;\n    rectItem.height = rectStore[++id] || 0;\n\n    return rectItem;\n  };\n\n  /**\n   * Punch a hole into a rectangle and split the remaining area into smaller\n   * rectangles (4 at max).\n   *\n   * @private\n   * @memberof Packer.prototype\n   * @param {Rectangle} rect\n   * @param {Rectangle} hole\n   * @returns {RectId[]}\n   */\n  Packer.prototype._splitRect = (function() {\n    var results = [];\n    return function(rect, hole) {\n      // Reset old results.\n      results.length = 0;\n\n      // If the rect does not overlap with the hole add rect to the return data\n      // as is.\n      if (!this._doRectsOverlap(rect, hole)) {\n        results.push(this._addRect(rect.left, rect.top, rect.width, rect.height));\n        return results;\n      }\n\n      // Left split.\n      if (rect.left < hole.left) {\n        results.push(this._addRect(rect.left, rect.top, hole.left - rect.left, rect.height));\n      }\n\n      // Right split.\n      if (rect.left + rect.width > hole.left + hole.width) {\n        results.push(\n          this._addRect(\n            hole.left + hole.width,\n            rect.top,\n            rect.left + rect.width - (hole.left + hole.width),\n            rect.height\n          )\n        );\n      }\n\n      // Top split.\n      if (rect.top < hole.top) {\n        results.push(this._addRect(rect.left, rect.top, rect.width, hole.top - rect.top));\n      }\n\n      // Bottom split.\n      if (rect.top + rect.height > hole.top + hole.height) {\n        results.push(\n          this._addRect(\n            rect.left,\n            hole.top + hole.height,\n            rect.width,\n            rect.top + rect.height - (hole.top + hole.height)\n          )\n        );\n      }\n\n      return results;\n    };\n  })();\n\n  /**\n   * Check if two rectangles overlap.\n   *\n   * @private\n   * @memberof Packer.prototype\n   * @param {Rectangle} a\n   * @param {Rectangle} b\n   * @returns {Boolean}\n   */\n  Packer.prototype._doRectsOverlap = function(a, b) {\n    return !(\n      a.left + a.width <= b.left ||\n      b.left + b.width <= a.left ||\n      a.top + a.height <= b.top ||\n      b.top + b.height <= a.top\n    );\n  };\n\n  /**\n   * Check if a rectangle is fully within another rectangle.\n   *\n   * @private\n   * @memberof Packer.prototype\n   * @param {Rectangle} a\n   * @param {Rectangle} b\n   * @returns {Boolean}\n   */\n  Packer.prototype._isRectWithinRect = function(a, b) {\n    return (\n      a.left >= b.left &&\n      a.top >= b.top &&\n      a.left + a.width <= b.left + b.width &&\n      a.top + a.height <= b.top + b.height\n    );\n  };\n\n  /**\n   * Loops through an array of rectangle ids and resets all that are fully\n   * within another rectangle in the array. Resetting in this case means that\n   * the rectangle id value is replaced with zero.\n   *\n   * @private\n   * @memberof Packer.prototype\n   * @param {RectId[]} rectIds\n   * @returns {RectId[]}\n   */\n  Packer.prototype._purgeRects = (function() {\n    var rectA = {};\n    var rectB = {};\n    return function(rectIds) {\n      var i = rectIds.length;\n      var ii;\n\n      while (i--) {\n        ii = rectIds.length;\n        if (!rectIds[i]) continue;\n        this._getRect(rectIds[i], rectA);\n        while (ii--) {\n          if (!rectIds[ii] || i === ii) continue;\n          if (this._isRectWithinRect(rectA, this._getRect(rectIds[ii], rectB))) {\n            rectIds[i] = 0;\n            break;\n          }\n        }\n      }\n\n      return rectIds;\n    };\n  })();\n\n  /**\n   * Sort rectangles with top-left gravity.\n   *\n   * @private\n   * @memberof Packer.prototype\n   * @param {RectId} aId\n   * @param {RectId} bId\n   * @returns {Number}\n   */\n  Packer.prototype._sortRectsTopLeft = (function() {\n    var rectA = {};\n    var rectB = {};\n    return function(aId, bId) {\n      this._getRect(aId, rectA);\n      this._getRect(bId, rectB);\n      // prettier-ignore\n      return rectA.top < rectB.top ? -1 :\n             rectA.top > rectB.top ? 1 :\n             rectA.left < rectB.left ? -1 :\n             rectA.left > rectB.left ? 1 : 0;\n    };\n  })();\n\n  /**\n   * Sort rectangles with left-top gravity.\n   *\n   * @private\n   * @memberof Packer.prototype\n   * @param {RectId} aId\n   * @param {RectId} bId\n   * @returns {Number}\n   */\n  Packer.prototype._sortRectsLeftTop = (function() {\n    var rectA = {};\n    var rectB = {};\n    return function(aId, bId) {\n      this._getRect(aId, rectA);\n      this._getRect(bId, rectB);\n      // prettier-ignore\n      return rectA.left < rectB.left ? -1 :\n             rectA.left > rectB.left ? 1 :\n             rectA.top < rectB.top ? -1 :\n             rectA.top > rectB.top ? 1 : 0;\n    };\n  })();\n\n  var htmlCollectionType = '[object HTMLCollection]';\n  var nodeListType = '[object NodeList]';\n\n  /**\n   * Check if a value is a node list\n   *\n   * @param {*} val\n   * @returns {Boolean}\n   */\n  function isNodeList(val) {\n    var type = Object.prototype.toString.call(val);\n    return type === htmlCollectionType || type === nodeListType;\n  }\n\n  var objectType = 'object';\n  var objectToStringType = '[object Object]';\n  var toString = Object.prototype.toString;\n\n  /**\n   * Check if a value is a plain object.\n   *\n   * @param {*} val\n   * @returns {Boolean}\n   */\n  function isPlainObject(val) {\n    return typeof val === objectType && toString.call(val) === objectToStringType;\n  }\n\n  /**\n   * Converts a value to an array or clones an array.\n   *\n   * @param {*} target\n   * @returns {Array}\n   */\n  function toArray(target) {\n    return isNodeList(target) ? Array.prototype.slice.call(target) : Array.prototype.concat(target);\n  }\n\n  var packer = new Packer();\n  var noop = function() {};\n\n  var numberType$1 = 'number';\n  var stringType = 'string';\n  var instantLayout = 'instant';\n\n  /**\n   * Creates a new Grid instance.\n   *\n   * @class\n   * @param {(HTMLElement|String)} element\n   * @param {Object} [options]\n   * @param {?(HTMLElement[]|NodeList|String)} [options.items]\n   * @param {Number} [options.showDuration=300]\n   * @param {String} [options.showEasing=\"ease\"]\n   * @param {Object} [options.visibleStyles]\n   * @param {Number} [options.hideDuration=300]\n   * @param {String} [options.hideEasing=\"ease\"]\n   * @param {Object} [options.hiddenStyles]\n   * @param {(Function|Object)} [options.layout]\n   * @param {Boolean} [options.layout.fillGaps=false]\n   * @param {Boolean} [options.layout.horizontal=false]\n   * @param {Boolean} [options.layout.alignRight=false]\n   * @param {Boolean} [options.layout.alignBottom=false]\n   * @param {Boolean} [options.layout.rounding=true]\n   * @param {(Boolean|Number)} [options.layoutOnResize=100]\n   * @param {Boolean} [options.layoutOnInit=true]\n   * @param {Number} [options.layoutDuration=300]\n   * @param {String} [options.layoutEasing=\"ease\"]\n   * @param {?Object} [options.sortData=null]\n   * @param {Boolean} [options.dragEnabled=false]\n   * @param {?HtmlElement} [options.dragContainer=null]\n   * @param {?Function} [options.dragStartPredicate]\n   * @param {Number} [options.dragStartPredicate.distance=0]\n   * @param {Number} [options.dragStartPredicate.delay=0]\n   * @param {(Boolean|String)} [options.dragStartPredicate.handle=false]\n   * @param {?String} [options.dragAxis]\n   * @param {(Boolean|Function)} [options.dragSort=true]\n   * @param {Object} [options.dragSortHeuristics]\n   * @param {Number} [options.dragSortHeuristics.sortInterval=100]\n   * @param {Number} [options.dragSortHeuristics.minDragDistance=10]\n   * @param {Number} [options.dragSortHeuristics.minBounceBackAngle=1]\n   * @param {(Function|Object)} [options.dragSortPredicate]\n   * @param {Number} [options.dragSortPredicate.threshold=50]\n   * @param {String} [options.dragSortPredicate.action=\"move\"]\n   * @param {Number} [options.dragReleaseDuration=300]\n   * @param {String} [options.dragReleaseEasing=\"ease\"]\n   * @param {Object} [options.dragCssProps]\n   * @param {Object} [options.dragPlaceholder]\n   * @param {Boolean} [options.dragPlaceholder.enabled=false]\n   * @param {Number} [options.dragPlaceholder.duration=300]\n   * @param {String} [options.dragPlaceholder.easing=\"ease\"]\n   * @param {?Function} [options.dragPlaceholder.createElement=null]\n   * @param {?Function} [options.dragPlaceholder.onCreate=null]\n   * @param {?Function} [options.dragPlaceholder.onRemove=null]\n   * @param {String} [options.containerClass=\"muuri\"]\n   * @param {String} [options.itemClass=\"muuri-item\"]\n   * @param {String} [options.itemVisibleClass=\"muuri-item-visible\"]\n   * @param {String} [options.itemHiddenClass=\"muuri-item-hidden\"]\n   * @param {String} [options.itemPositioningClass=\"muuri-item-positioning\"]\n   * @param {String} [options.itemDraggingClass=\"muuri-item-dragging\"]\n   * @param {String} [options.itemReleasingClass=\"muuri-item-releasing\"]\n   * @param {String} [options.itemPlaceholderClass=\"muuri-item-placeholder\"]\n   */\n\n  function Grid(element, options) {\n    var inst = this;\n    var settings;\n    var items;\n    var layoutOnResize;\n\n    // Allow passing element as selector string. Store element for instance.\n    element = this._element =\n      typeof element === stringType ? window.document.querySelector(element) : element;\n\n    // Throw an error if the container element is not body element or does not\n    // exist within the body element.\n    var isElementInDom = element.getRootNode\n      ? element.getRootNode({ composed: true }) === document\n      : window.document.body.contains(element);\n    if (!isElementInDom || element === window.document.documentElement) {\n      throw new Error('Container element must be an existing DOM element');\n    }\n\n    // Create instance settings by merging the options with default options.\n    settings = this._settings = mergeSettings(Grid.defaultOptions, options);\n\n    // Sanitize dragSort setting.\n    if (!isFunction(settings.dragSort)) {\n      settings.dragSort = !!settings.dragSort;\n    }\n\n    // Create instance id and store it to the grid instances collection.\n    this._id = createUid();\n    gridInstances[this._id] = inst;\n\n    // Destroyed flag.\n    this._isDestroyed = false;\n\n    // The layout object (mutated on every layout).\n    this._layout = {\n      id: 0,\n      items: [],\n      slots: [],\n      setWidth: false,\n      setHeight: false,\n      width: 0,\n      height: 0\n    };\n\n    // Create private Emitter instance.\n    this._emitter = new Emitter();\n\n    // Add container element's class name.\n    addClass(element, settings.containerClass);\n\n    // Create initial items.\n    this._items = [];\n    items = settings.items;\n    if (typeof items === stringType) {\n      toArray(element.children).forEach(function(itemElement) {\n        if (items === '*' || elementMatches(itemElement, items)) {\n          inst._items.push(new Item(inst, itemElement));\n        }\n      });\n    } else if (Array.isArray(items) || isNodeList(items)) {\n      this._items = toArray(items).map(function(itemElement) {\n        return new Item(inst, itemElement);\n      });\n    }\n\n    // If layoutOnResize option is a valid number sanitize it and bind the resize\n    // handler.\n    layoutOnResize = settings.layoutOnResize;\n    if (typeof layoutOnResize !== numberType$1) {\n      layoutOnResize = layoutOnResize === true ? 0 : -1;\n    }\n    if (layoutOnResize >= 0) {\n      window.addEventListener(\n        'resize',\n        (inst._resizeHandler = debounce(function() {\n          inst.refreshItems().layout();\n        }, layoutOnResize))\n      );\n    }\n\n    // Layout on init if necessary.\n    if (settings.layoutOnInit) {\n      this.layout(true);\n    }\n  }\n\n  /**\n   * Public properties\n   * *****************\n   */\n\n  /**\n   * @see Item\n   */\n  Grid.Item = Item;\n\n  /**\n   * @see ItemLayout\n   */\n  Grid.ItemLayout = ItemLayout;\n\n  /**\n   * @see ItemVisibility\n   */\n  Grid.ItemVisibility = ItemVisibility;\n\n  /**\n   * @see ItemMigrate\n   */\n  Grid.ItemMigrate = ItemMigrate;\n\n  /**\n   * @see ItemAnimate\n   */\n  Grid.ItemAnimate = ItemAnimate;\n\n  /**\n   * @see ItemDrag\n   */\n  Grid.ItemDrag = ItemDrag;\n\n  /**\n   * @see ItemRelease\n   */\n  Grid.ItemRelease = ItemRelease;\n\n  /**\n   * @see ItemDragPlaceholder\n   */\n  Grid.ItemDragPlaceholder = ItemDragPlaceholder;\n\n  /**\n   * @see Emitter\n   */\n  Grid.Emitter = Emitter;\n\n  /**\n   * @see Dragger\n   */\n  Grid.Dragger = Dragger;\n\n  /**\n   * @see Packer\n   */\n  Grid.Packer = Packer;\n\n  /**\n   * Default options for Grid instance.\n   *\n   * @public\n   * @memberof Grid\n   */\n  Grid.defaultOptions = {\n    // Item elements\n    items: '*',\n\n    // Default show animation\n    showDuration: 300,\n    showEasing: 'ease',\n\n    // Default hide animation\n    hideDuration: 300,\n    hideEasing: 'ease',\n\n    // Item's visible/hidden state styles\n    visibleStyles: {\n      opacity: '1',\n      transform: 'scale(1)'\n    },\n    hiddenStyles: {\n      opacity: '0',\n      transform: 'scale(0.5)'\n    },\n\n    // Layout\n    layout: {\n      fillGaps: false,\n      horizontal: false,\n      alignRight: false,\n      alignBottom: false,\n      rounding: true\n    },\n    layoutOnResize: 100,\n    layoutOnInit: true,\n    layoutDuration: 300,\n    layoutEasing: 'ease',\n\n    // Sorting\n    sortData: null,\n\n    // Drag & Drop\n    dragEnabled: false,\n    dragContainer: null,\n    dragStartPredicate: {\n      distance: 0,\n      delay: 0,\n      handle: false\n    },\n    dragAxis: null,\n    dragSort: true,\n    dragSortHeuristics: {\n      sortInterval: 100,\n      minDragDistance: 10,\n      minBounceBackAngle: 1\n    },\n    dragSortPredicate: {\n      threshold: 50,\n      action: actionMove\n    },\n    dragReleaseDuration: 300,\n    dragReleaseEasing: 'ease',\n    dragCssProps: {\n      touchAction: 'none',\n      userSelect: 'none',\n      userDrag: 'none',\n      tapHighlightColor: 'rgba(0, 0, 0, 0)',\n      touchCallout: 'none',\n      contentZooming: 'none'\n    },\n    dragPlaceholder: {\n      enabled: false,\n      duration: 300,\n      easing: 'ease',\n      createElement: null,\n      onCreate: null,\n      onRemove: null\n    },\n\n    // Classnames\n    containerClass: 'muuri',\n    itemClass: 'muuri-item',\n    itemVisibleClass: 'muuri-item-shown',\n    itemHiddenClass: 'muuri-item-hidden',\n    itemPositioningClass: 'muuri-item-positioning',\n    itemDraggingClass: 'muuri-item-dragging',\n    itemReleasingClass: 'muuri-item-releasing',\n    itemPlaceholderClass: 'muuri-item-placeholder'\n  };\n\n  /**\n   * Public prototype methods\n   * ************************\n   */\n\n  /**\n   * Bind an event listener.\n   *\n   * @public\n   * @memberof Grid.prototype\n   * @param {String} event\n   * @param {Function} listener\n   * @returns {Grid}\n   */\n  Grid.prototype.on = function(event, listener) {\n    this._emitter.on(event, listener);\n    return this;\n  };\n\n  /**\n   * Unbind an event listener.\n   *\n   * @public\n   * @memberof Grid.prototype\n   * @param {String} event\n   * @param {Function} listener\n   * @returns {Grid}\n   */\n  Grid.prototype.off = function(event, listener) {\n    this._emitter.off(event, listener);\n    return this;\n  };\n\n  /**\n   * Get the container element.\n   *\n   * @public\n   * @memberof Grid.prototype\n   * @returns {HTMLElement}\n   */\n  Grid.prototype.getElement = function() {\n    return this._element;\n  };\n\n  /**\n   * Get all items. Optionally you can provide specific targets (elements and\n   * indices). Note that the returned array is not the same object used by the\n   * instance so modifying it will not affect instance's items. All items that\n   * are not found are omitted from the returned array.\n   *\n   * @public\n   * @memberof Grid.prototype\n   * @param {GridMultiItemQuery} [targets]\n   * @returns {Item[]}\n   */\n  Grid.prototype.getItems = function(targets) {\n    // Return all items immediately if no targets were provided or if the\n    // instance is destroyed.\n    if (this._isDestroyed || (!targets && targets !== 0)) {\n      return this._items.slice(0);\n    }\n\n    var ret = [];\n    var targetItems = toArray(targets);\n    var item;\n    var i;\n\n    // If target items are defined return filtered results.\n    for (i = 0; i < targetItems.length; i++) {\n      item = this._getItem(targetItems[i]);\n      item && ret.push(item);\n    }\n\n    return ret;\n  };\n\n  /**\n   * Update the cached dimensions of the instance's items.\n   *\n   * @public\n   * @memberof Grid.prototype\n   * @param {GridMultiItemQuery} [items]\n   * @returns {Grid}\n   */\n  Grid.prototype.refreshItems = function(items) {\n    if (this._isDestroyed) return this;\n\n    var targets = this.getItems(items);\n    var i;\n\n    for (i = 0; i < targets.length; i++) {\n      targets[i]._refreshDimensions();\n    }\n\n    return this;\n  };\n\n  /**\n   * Update the sort data of the instance's items.\n   *\n   * @public\n   * @memberof Grid.prototype\n   * @param {GridMultiItemQuery} [items]\n   * @returns {Grid}\n   */\n  Grid.prototype.refreshSortData = function(items) {\n    if (this._isDestroyed) return this;\n\n    var targetItems = this.getItems(items);\n    var i;\n\n    for (i = 0; i < targetItems.length; i++) {\n      targetItems[i]._refreshSortData();\n    }\n\n    return this;\n  };\n\n  /**\n   * Synchronize the item elements to match the order of the items in the DOM.\n   * This comes handy if you need to keep the DOM structure matched with the\n   * order of the items. Note that if an item's element is not currently a child\n   * of the container element (if it is dragged for example) it is ignored and\n   * left untouched.\n   *\n   * @public\n   * @memberof Grid.prototype\n   * @returns {Grid}\n   */\n  Grid.prototype.synchronize = function() {\n    if (this._isDestroyed) return this;\n\n    var container = this._element;\n    var items = this._items;\n    var fragment;\n    var element;\n    var i;\n\n    // Append all elements in order to the container element.\n    if (items.length) {\n      for (i = 0; i < items.length; i++) {\n        element = items[i]._element;\n        if (element.parentNode === container) {\n          fragment = fragment || window.document.createDocumentFragment();\n          fragment.appendChild(element);\n        }\n      }\n\n      if (fragment) container.appendChild(fragment);\n    }\n\n    // Emit synchronize event.\n    this._emit(eventSynchronize);\n\n    return this;\n  };\n\n  /**\n   * Calculate and apply item positions.\n   *\n   * @public\n   * @memberof Grid.prototype\n   * @param {Boolean} [instant=false]\n   * @param {LayoutCallback} [onFinish]\n   * @returns {Grid}\n   */\n  Grid.prototype.layout = function(instant, onFinish) {\n    if (this._isDestroyed) return this;\n\n    var inst = this;\n    var element = this._element;\n    var layout = this._updateLayout();\n    var layoutId = layout.id;\n    var itemsLength = layout.items.length;\n    var counter = itemsLength;\n    var isBorderBox;\n    var item;\n    var i;\n\n    // The finish function, which will be used for checking if all the items\n    // have laid out yet. After all items have finished their animations call\n    // callback and emit layoutEnd event. Only emit layoutEnd event if there\n    // hasn't been a new layout call during this layout.\n    function tryFinish() {\n      if (--counter > 0) return;\n\n      var hasLayoutChanged = inst._layout.id !== layoutId;\n      var callback = isFunction(instant) ? instant : onFinish;\n\n      if (isFunction(callback)) {\n        callback(hasLayoutChanged, layout.items.slice(0));\n      }\n\n      if (!hasLayoutChanged && inst._hasListeners(eventLayoutEnd)) {\n        inst._emit(eventLayoutEnd, layout.items.slice(0));\n      }\n    }\n\n    // If grid's width or height was modified, we need to update it's cached\n    // dimensions. Also keep in mind that grid's cached width/height should\n    // always equal to what elem.getBoundingClientRect() would return, so\n    // therefore we need to add the grid element's borders to the dimensions if\n    // it's box-sizing is border-box. Note that we support providing the\n    // dimensions as a string here too so that one can define the unit of the\n    // dimensions, in which case we don't do the border-box check.\n    if (\n      (layout.setHeight && typeof layout.height === numberType$1) ||\n      (layout.setWidth && typeof layout.width === numberType$1)\n    ) {\n      isBorderBox = getStyle(element, 'box-sizing') === 'border-box';\n    }\n    if (layout.setHeight) {\n      if (typeof layout.height === numberType$1) {\n        element.style.height =\n          (isBorderBox ? layout.height + this._borderTop + this._borderBottom : layout.height) + 'px';\n      } else {\n        element.style.height = layout.height;\n      }\n    }\n    if (layout.setWidth) {\n      if (typeof layout.width === numberType$1) {\n        element.style.width =\n          (isBorderBox ? layout.width + this._borderLeft + this._borderRight : layout.width) + 'px';\n      } else {\n        element.style.width = layout.width;\n      }\n    }\n\n    // Emit layoutStart event. Note that this is intentionally emitted after the\n    // container element's dimensions are set, because otherwise there would be\n    // no hook for reacting to container dimension changes.\n    if (this._hasListeners(eventLayoutStart)) {\n      this._emit(eventLayoutStart, layout.items.slice(0));\n    }\n\n    // If there are no items let's finish quickly.\n    if (!itemsLength) {\n      tryFinish();\n      return this;\n    }\n\n    // If there are items let's position them.\n    for (i = 0; i < itemsLength; i++) {\n      item = layout.items[i];\n      if (!item) continue;\n\n      // Update item's position.\n      item._left = layout.slots[i * 2];\n      item._top = layout.slots[i * 2 + 1];\n\n      // Layout item if it is not dragged.\n      item.isDragging() ? tryFinish() : item._layout.start(instant === true, tryFinish);\n    }\n\n    return this;\n  };\n\n  /**\n   * Add new items by providing the elements you wish to add to the instance and\n   * optionally provide the index where you want the items to be inserted into.\n   * All elements that are not already children of the container element will be\n   * automatically appended to the container element. If an element has it's CSS\n   * display property set to \"none\" it will be marked as inactive during the\n   * initiation process. As long as the item is inactive it will not be part of\n   * the layout, but it will retain it's index. You can activate items at any\n   * point with grid.show() method. This method will automatically call\n   * grid.layout() if one or more of the added elements are visible. If only\n   * hidden items are added no layout will be called. All the new visible items\n   * are positioned without animation during their first layout.\n   *\n   * @public\n   * @memberof Grid.prototype\n   * @param {(HTMLElement|HTMLElement[])} elements\n   * @param {Object} [options]\n   * @param {Number} [options.index=-1]\n   * @param {Boolean} [options.isActive]\n   * @param {(Boolean|LayoutCallback|String)} [options.layout=true]\n   * @returns {Item[]}\n   */\n  Grid.prototype.add = function(elements, options) {\n    if (this._isDestroyed || !elements) return [];\n\n    var newItems = toArray(elements);\n    if (!newItems.length) return newItems;\n\n    var opts = options || 0;\n    var layout = opts.layout ? opts.layout : opts.layout === undefined;\n    var items = this._items;\n    var needsLayout = false;\n    var item;\n    var i;\n\n    // Map provided elements into new grid items.\n    for (i = 0; i < newItems.length; i++) {\n      item = new Item(this, newItems[i], opts.isActive);\n      newItems[i] = item;\n\n      // If the item to be added is active, we need to do a layout. Also, we\n      // need to mark the item with the skipNextAnimation flag to make it\n      // position instantly (without animation) during the next layout. Without\n      // the hack the item would animate to it's new position from the northwest\n      // corner of the grid, which feels a bit buggy (imho).\n      if (item._isActive) {\n        needsLayout = true;\n        item._layout._skipNextAnimation = true;\n      }\n    }\n\n    // Add the new items to the items collection to correct index.\n    arrayInsert(items, newItems, opts.index);\n\n    // Emit add event.\n    if (this._hasListeners(eventAdd)) {\n      this._emit(eventAdd, newItems.slice(0));\n    }\n\n    // If layout is needed.\n    if (needsLayout && layout) {\n      this.layout(layout === instantLayout, isFunction(layout) ? layout : undefined);\n    }\n\n    return newItems;\n  };\n\n  /**\n   * Remove items from the instance.\n   *\n   * @public\n   * @memberof Grid.prototype\n   * @param {GridMultiItemQuery} items\n   * @param {Object} [options]\n   * @param {Boolean} [options.removeElements=false]\n   * @param {(Boolean|LayoutCallback|String)} [options.layout=true]\n   * @returns {Item[]}\n   */\n  Grid.prototype.remove = function(items, options) {\n    if (this._isDestroyed) return this;\n\n    var opts = options || 0;\n    var layout = opts.layout ? opts.layout : opts.layout === undefined;\n    var needsLayout = false;\n    var allItems = this.getItems();\n    var targetItems = this.getItems(items);\n    var indices = [];\n    var item;\n    var i;\n\n    // Remove the individual items.\n    for (i = 0; i < targetItems.length; i++) {\n      item = targetItems[i];\n      indices.push(allItems.indexOf(item));\n      if (item._isActive) needsLayout = true;\n      item._destroy(opts.removeElements);\n    }\n\n    // Emit remove event.\n    if (this._hasListeners(eventRemove)) {\n      this._emit(eventRemove, targetItems.slice(0), indices);\n    }\n\n    // If layout is needed.\n    if (needsLayout && layout) {\n      this.layout(layout === instantLayout, isFunction(layout) ? layout : undefined);\n    }\n\n    return targetItems;\n  };\n\n  /**\n   * Show instance items.\n   *\n   * @public\n   * @memberof Grid.prototype\n   * @param {GridMultiItemQuery} items\n   * @param {Object} [options]\n   * @param {Boolean} [options.instant=false]\n   * @param {ShowCallback} [options.onFinish]\n   * @param {(Boolean|LayoutCallback|String)} [options.layout=true]\n   * @returns {Grid}\n   */\n  Grid.prototype.show = function(items, options) {\n    if (this._isDestroyed) return this;\n    this._setItemsVisibility(items, true, options);\n    return this;\n  };\n\n  /**\n   * Hide instance items.\n   *\n   * @public\n   * @memberof Grid.prototype\n   * @param {GridMultiItemQuery} items\n   * @param {Object} [options]\n   * @param {Boolean} [options.instant=false]\n   * @param {HideCallback} [options.onFinish]\n   * @param {(Boolean|LayoutCallback|String)} [options.layout=true]\n   * @returns {Grid}\n   */\n  Grid.prototype.hide = function(items, options) {\n    if (this._isDestroyed) return this;\n    this._setItemsVisibility(items, false, options);\n    return this;\n  };\n\n  /**\n   * Filter items. Expects at least one argument, a predicate, which should be\n   * either a function or a string. The predicate callback is executed for every\n   * item in the instance. If the return value of the predicate is truthy the\n   * item in question will be shown and otherwise hidden. The predicate callback\n   * receives the item instance as it's argument. If the predicate is a string\n   * it is considered to be a selector and it is checked against every item\n   * element in the instance with the native element.matches() method. All the\n   * matching items will be shown and others hidden.\n   *\n   * @public\n   * @memberof Grid.prototype\n   * @param {(Function|String)} predicate\n   * @param {Object} [options]\n   * @param {Boolean} [options.instant=false]\n   * @param {FilterCallback} [options.onFinish]\n   * @param {(Boolean|LayoutCallback|String)} [options.layout=true]\n   * @returns {Grid}\n   */\n  Grid.prototype.filter = function(predicate, options) {\n    if (this._isDestroyed || !this._items.length) return this;\n\n    var itemsToShow = [];\n    var itemsToHide = [];\n    var isPredicateString = typeof predicate === stringType;\n    var isPredicateFn = isFunction(predicate);\n    var opts = options || 0;\n    var isInstant = opts.instant === true;\n    var layout = opts.layout ? opts.layout : opts.layout === undefined;\n    var onFinish = isFunction(opts.onFinish) ? opts.onFinish : null;\n    var tryFinishCounter = -1;\n    var tryFinish = noop;\n    var item;\n    var i;\n\n    // If we have onFinish callback, let's create proper tryFinish callback.\n    if (onFinish) {\n      tryFinish = function() {\n        ++tryFinishCounter && onFinish(itemsToShow.slice(0), itemsToHide.slice(0));\n      };\n    }\n\n    // Check which items need to be shown and which hidden.\n    if (isPredicateFn || isPredicateString) {\n      for (i = 0; i < this._items.length; i++) {\n        item = this._items[i];\n        if (isPredicateFn ? predicate(item) : elementMatches(item._element, predicate)) {\n          itemsToShow.push(item);\n        } else {\n          itemsToHide.push(item);\n        }\n      }\n    }\n\n    // Show items that need to be shown.\n    if (itemsToShow.length) {\n      this.show(itemsToShow, {\n        instant: isInstant,\n        onFinish: tryFinish,\n        layout: false\n      });\n    } else {\n      tryFinish();\n    }\n\n    // Hide items that need to be hidden.\n    if (itemsToHide.length) {\n      this.hide(itemsToHide, {\n        instant: isInstant,\n        onFinish: tryFinish,\n        layout: false\n      });\n    } else {\n      tryFinish();\n    }\n\n    // If there are any items to filter.\n    if (itemsToShow.length || itemsToHide.length) {\n      // Emit filter event.\n      if (this._hasListeners(eventFilter)) {\n        this._emit(eventFilter, itemsToShow.slice(0), itemsToHide.slice(0));\n      }\n\n      // If layout is needed.\n      if (layout) {\n        this.layout(layout === instantLayout, isFunction(layout) ? layout : undefined);\n      }\n    }\n\n    return this;\n  };\n\n  /**\n   * Sort items. There are three ways to sort the items. The first is simply by\n   * providing a function as the comparer which works identically to native\n   * array sort. Alternatively you can sort by the sort data you have provided\n   * in the instance's options. Just provide the sort data key(s) as a string\n   * (separated by space) and the items will be sorted based on the provided\n   * sort data keys. Lastly you have the opportunity to provide a presorted\n   * array of items which will be used to sync the internal items array in the\n   * same order.\n   *\n   * @public\n   * @memberof Grid.prototype\n   * @param {(Function|Item[]|String|String[])} comparer\n   * @param {Object} [options]\n   * @param {Boolean} [options.descending=false]\n   * @param {(Boolean|LayoutCallback|String)} [options.layout=true]\n   * @returns {Grid}\n   */\n  Grid.prototype.sort = (function() {\n    var sortComparer;\n    var isDescending;\n    var origItems;\n    var indexMap;\n\n    function parseCriteria(data) {\n      return data\n        .trim()\n        .split(' ')\n        .map(function(val) {\n          return val.split(':');\n        });\n    }\n\n    function getIndexMap(items) {\n      var ret = {};\n      for (var i = 0; i < items.length; i++) {\n        ret[items[i]._id] = i;\n      }\n      return ret;\n    }\n\n    function compareIndices(itemA, itemB) {\n      var indexA = indexMap[itemA._id];\n      var indexB = indexMap[itemB._id];\n      return isDescending ? indexB - indexA : indexA - indexB;\n    }\n\n    function defaultComparer(a, b) {\n      var result = 0;\n      var criteriaName;\n      var criteriaOrder;\n      var valA;\n      var valB;\n\n      // Loop through the list of sort criteria.\n      for (var i = 0; i < sortComparer.length; i++) {\n        // Get the criteria name, which should match an item's sort data key.\n        criteriaName = sortComparer[i][0];\n        criteriaOrder = sortComparer[i][1];\n\n        // Get items' cached sort values for the criteria. If the item has no sort\n        // data let's update the items sort data (this is a lazy load mechanism).\n        valA = (a._sortData ? a : a._refreshSortData())._sortData[criteriaName];\n        valB = (b._sortData ? b : b._refreshSortData())._sortData[criteriaName];\n\n        // Sort the items in descending order if defined so explicitly. Otherwise\n        // sort items in ascending order.\n        if (criteriaOrder === 'desc' || (!criteriaOrder && isDescending)) {\n          result = valB < valA ? -1 : valB > valA ? 1 : 0;\n        } else {\n          result = valA < valB ? -1 : valA > valB ? 1 : 0;\n        }\n\n        // If we have -1 or 1 as the return value, let's return it immediately.\n        if (result) return result;\n      }\n\n      // If values are equal let's compare the item indices to make sure we\n      // have a stable sort.\n      if (!result) {\n        if (!indexMap) indexMap = getIndexMap(origItems);\n        result = compareIndices(a, b);\n      }\n      return result;\n    }\n\n    function customComparer(a, b) {\n      var result = sortComparer(a, b);\n      // If descending let's invert the result value.\n      if (isDescending && result) result = -result;\n      // If we have a valid result (not zero) let's return it right away.\n      if (result) return result;\n      // If result is zero let's compare the item indices to make sure we have a\n      // stable sort.\n      if (!indexMap) indexMap = getIndexMap(origItems);\n      return compareIndices(a, b);\n    }\n\n    return function(comparer, options) {\n      if (this._isDestroyed || this._items.length < 2) return this;\n\n      var items = this._items;\n      var opts = options || 0;\n      var layout = opts.layout ? opts.layout : opts.layout === undefined;\n      var i;\n\n      // Setup parent scope data.\n      sortComparer = comparer;\n      isDescending = !!opts.descending;\n      origItems = items.slice(0);\n      indexMap = null;\n\n      // If function is provided do a native array sort.\n      if (isFunction(sortComparer)) {\n        items.sort(customComparer);\n      }\n      // Otherwise if we got a string, let's sort by the sort data as provided in\n      // the instance's options.\n      else if (typeof sortComparer === stringType) {\n        sortComparer = parseCriteria(comparer);\n        items.sort(defaultComparer);\n      }\n      // Otherwise if we got an array, let's assume it's a presorted array of the\n      // items and order the items based on it.\n      else if (Array.isArray(sortComparer)) {\n        if (sortComparer.length !== items.length) {\n          throw new Error('[' + namespace + '] sort reference items do not match with grid items.');\n        }\n        for (i = 0; i < items.length; i++) {\n          if (sortComparer.indexOf(items[i]) < 0) {\n            throw new Error('[' + namespace + '] sort reference items do not match with grid items.');\n          }\n          items[i] = sortComparer[i];\n        }\n        if (isDescending) items.reverse();\n      }\n      // Otherwise let's just skip it, nothing we can do here.\n      else {\n        /** @todo Maybe throw an error here? */\n        return this;\n      }\n\n      // Emit sort event.\n      if (this._hasListeners(eventSort)) {\n        this._emit(eventSort, items.slice(0), origItems);\n      }\n\n      // If layout is needed.\n      if (layout) {\n        this.layout(layout === instantLayout, isFunction(layout) ? layout : undefined);\n      }\n\n      return this;\n    };\n  })();\n\n  /**\n   * Move item to another index or in place of another item.\n   *\n   * @public\n   * @memberof Grid.prototype\n   * @param {GridSingleItemQuery} item\n   * @param {GridSingleItemQuery} position\n   * @param {Object} [options]\n   * @param {String} [options.action=\"move\"]\n   *   - Accepts either \"move\" or \"swap\".\n   *   - \"move\" moves the item in place of the other item.\n   *   - \"swap\" swaps the position of the items.\n   * @param {(Boolean|LayoutCallback|String)} [options.layout=true]\n   * @returns {Grid}\n   */\n  Grid.prototype.move = function(item, position, options) {\n    if (this._isDestroyed || this._items.length < 2) return this;\n\n    var items = this._items;\n    var opts = options || 0;\n    var layout = opts.layout ? opts.layout : opts.layout === undefined;\n    var isSwap = opts.action === actionSwap;\n    var action = isSwap ? actionSwap : actionMove;\n    var fromItem = this._getItem(item);\n    var toItem = this._getItem(position);\n    var fromIndex;\n    var toIndex;\n\n    // Make sure the items exist and are not the same.\n    if (fromItem && toItem && fromItem !== toItem) {\n      // Get the indices of the items.\n      fromIndex = items.indexOf(fromItem);\n      toIndex = items.indexOf(toItem);\n\n      // Do the move/swap.\n      if (isSwap) {\n        arraySwap(items, fromIndex, toIndex);\n      } else {\n        arrayMove(items, fromIndex, toIndex);\n      }\n\n      // Emit move event.\n      if (this._hasListeners(eventMove)) {\n        this._emit(eventMove, {\n          item: fromItem,\n          fromIndex: fromIndex,\n          toIndex: toIndex,\n          action: action\n        });\n      }\n\n      // If layout is needed.\n      if (layout) {\n        this.layout(layout === instantLayout, isFunction(layout) ? layout : undefined);\n      }\n    }\n\n    return this;\n  };\n\n  /**\n   * Send item to another Grid instance.\n   *\n   * @public\n   * @memberof Grid.prototype\n   * @param {GridSingleItemQuery} item\n   * @param {Grid} grid\n   * @param {GridSingleItemQuery} position\n   * @param {Object} [options]\n   * @param {HTMLElement} [options.appendTo=document.body]\n   * @param {(Boolean|LayoutCallback|String)} [options.layoutSender=true]\n   * @param {(Boolean|LayoutCallback|String)} [options.layoutReceiver=true]\n   * @returns {Grid}\n   */\n  Grid.prototype.send = function(item, grid, position, options) {\n    if (this._isDestroyed || grid._isDestroyed || this === grid) return this;\n\n    // Make sure we have a valid target item.\n    item = this._getItem(item);\n    if (!item) return this;\n\n    var opts = options || 0;\n    var container = opts.appendTo || window.document.body;\n    var layoutSender = opts.layoutSender ? opts.layoutSender : opts.layoutSender === undefined;\n    var layoutReceiver = opts.layoutReceiver\n      ? opts.layoutReceiver\n      : opts.layoutReceiver === undefined;\n\n    // Start the migration process.\n    item._migrate.start(grid, position, container);\n\n    // If migration was started successfully and the item is active, let's layout\n    // the grids.\n    if (item._migrate._isActive && item._isActive) {\n      if (layoutSender) {\n        this.layout(\n          layoutSender === instantLayout,\n          isFunction(layoutSender) ? layoutSender : undefined\n        );\n      }\n      if (layoutReceiver) {\n        grid.layout(\n          layoutReceiver === instantLayout,\n          isFunction(layoutReceiver) ? layoutReceiver : undefined\n        );\n      }\n    }\n\n    return this;\n  };\n\n  /**\n   * Destroy the instance.\n   *\n   * @public\n   * @memberof Grid.prototype\n   * @param {Boolean} [removeElements=false]\n   * @returns {Grid}\n   */\n  Grid.prototype.destroy = function(removeElements) {\n    if (this._isDestroyed) return this;\n\n    var container = this._element;\n    var items = this._items.slice(0);\n    var i;\n\n    // Unbind window resize event listener.\n    if (this._resizeHandler) {\n      window.removeEventListener('resize', this._resizeHandler);\n    }\n\n    // Destroy items.\n    for (i = 0; i < items.length; i++) {\n      items[i]._destroy(removeElements);\n    }\n\n    // Restore container.\n    removeClass(container, this._settings.containerClass);\n    container.style.height = '';\n    container.style.width = '';\n\n    // Emit destroy event and unbind all events.\n    this._emit(eventDestroy);\n    this._emitter.destroy();\n\n    // Remove reference from the grid instances collection.\n    gridInstances[this._id] = undefined;\n\n    // Flag instance as destroyed.\n    this._isDestroyed = true;\n\n    return this;\n  };\n\n  /**\n   * Private prototype methods\n   * *************************\n   */\n\n  /**\n   * Get instance's item by element or by index. Target can also be an Item\n   * instance in which case the function returns the item if it exists within\n   * related Grid instance. If nothing is found with the provided target, null\n   * is returned.\n   *\n   * @private\n   * @memberof Grid.prototype\n   * @param {GridSingleItemQuery} [target]\n   * @returns {?Item}\n   */\n  Grid.prototype._getItem = function(target) {\n    // If no target is specified or the instance is destroyed, return null.\n    if (this._isDestroyed || (!target && target !== 0)) {\n      return null;\n    }\n\n    // If target is number return the item in that index. If the number is lower\n    // than zero look for the item starting from the end of the items array. For\n    // example -1 for the last item, -2 for the second last item, etc.\n    if (typeof target === numberType$1) {\n      return this._items[target > -1 ? target : this._items.length + target] || null;\n    }\n\n    // If the target is an instance of Item return it if it is attached to this\n    // Grid instance, otherwise return null.\n    if (target instanceof Item) {\n      return target._gridId === this._id ? target : null;\n    }\n\n    // In other cases let's assume that the target is an element, so let's try\n    // to find an item that matches the element and return it. If item is not\n    // found return null.\n    /** @todo This could be made a lot faster by using Map/WeakMap of elements. */\n    for (var i = 0; i < this._items.length; i++) {\n      if (this._items[i]._element === target) {\n        return this._items[i];\n      }\n    }\n\n    return null;\n  };\n\n  /**\n   * Recalculates and updates instance's layout data.\n   *\n   * @private\n   * @memberof Grid.prototype\n   * @returns {LayoutData}\n   */\n  Grid.prototype._updateLayout = function() {\n    var layout = this._layout;\n    var settings = this._settings.layout;\n    var width;\n    var height;\n    var newLayout;\n    var i;\n\n    // Let's increment layout id.\n    ++layout.id;\n\n    // Let's update layout items\n    layout.items.length = 0;\n    for (i = 0; i < this._items.length; i++) {\n      if (this._items[i]._isActive) layout.items.push(this._items[i]);\n    }\n\n    // Let's make sure we have the correct container dimensions.\n    this._refreshDimensions();\n\n    // Calculate container width and height (without borders).\n    width = this._width - this._borderLeft - this._borderRight;\n    height = this._height - this._borderTop - this._borderBottom;\n\n    // Calculate new layout.\n    if (isFunction(settings)) {\n      newLayout = settings(layout.items, width, height);\n    } else {\n      newLayout = packer.getLayout(layout.items, width, height, layout.slots, settings);\n    }\n\n    // Let's update the grid's layout.\n    layout.slots = newLayout.slots;\n    layout.setWidth = Boolean(newLayout.setWidth);\n    layout.setHeight = Boolean(newLayout.setHeight);\n    layout.width = newLayout.width;\n    layout.height = newLayout.height;\n\n    return layout;\n  };\n\n  /**\n   * Emit a grid event.\n   *\n   * @private\n   * @memberof Grid.prototype\n   * @param {String} event\n   * @param {...*} [arg]\n   */\n  Grid.prototype._emit = function() {\n    if (this._isDestroyed) return;\n    this._emitter.emit.apply(this._emitter, arguments);\n  };\n\n  /**\n   * Check if there are any events listeners for an event.\n   *\n   * @private\n   * @memberof Grid.prototype\n   * @param {String} event\n   * @returns {Boolean}\n   */\n  Grid.prototype._hasListeners = function(event) {\n    var listeners = this._emitter._events[event];\n    return !!(listeners && listeners.length);\n  };\n\n  /**\n   * Update container's width, height and offsets.\n   *\n   * @private\n   * @memberof Grid.prototype\n   */\n  Grid.prototype._updateBoundingRect = function() {\n    var element = this._element;\n    var rect = element.getBoundingClientRect();\n    this._width = rect.width;\n    this._height = rect.height;\n    this._left = rect.left;\n    this._top = rect.top;\n  };\n\n  /**\n   * Update container's border sizes.\n   *\n   * @private\n   * @memberof Grid.prototype\n   * @param {Boolean} left\n   * @param {Boolean} right\n   * @param {Boolean} top\n   * @param {Boolean} bottom\n   */\n  Grid.prototype._updateBorders = function(left, right, top, bottom) {\n    var element = this._element;\n    if (left) this._borderLeft = getStyleAsFloat(element, 'border-left-width');\n    if (right) this._borderRight = getStyleAsFloat(element, 'border-right-width');\n    if (top) this._borderTop = getStyleAsFloat(element, 'border-top-width');\n    if (bottom) this._borderBottom = getStyleAsFloat(element, 'border-bottom-width');\n  };\n\n  /**\n   * Refresh all of container's internal dimensions and offsets.\n   *\n   * @private\n   * @memberof Grid.prototype\n   */\n  Grid.prototype._refreshDimensions = function() {\n    this._updateBoundingRect();\n    this._updateBorders(1, 1, 1, 1);\n  };\n\n  /**\n   * Show or hide Grid instance's items.\n   *\n   * @private\n   * @memberof Grid.prototype\n   * @param {GridMultiItemQuery} items\n   * @param {Boolean} toVisible\n   * @param {Object} [options]\n   * @param {Boolean} [options.instant=false]\n   * @param {(ShowCallback|HideCallback)} [options.onFinish]\n   * @param {(Boolean|LayoutCallback|String)} [options.layout=true]\n   */\n  Grid.prototype._setItemsVisibility = function(items, toVisible, options) {\n    var grid = this;\n    var targetItems = this.getItems(items);\n    var opts = options || 0;\n    var isInstant = opts.instant === true;\n    var callback = opts.onFinish;\n    var layout = opts.layout ? opts.layout : opts.layout === undefined;\n    var counter = targetItems.length;\n    var startEvent = toVisible ? eventShowStart : eventHideStart;\n    var endEvent = toVisible ? eventShowEnd : eventHideEnd;\n    var method = toVisible ? 'show' : 'hide';\n    var needsLayout = false;\n    var completedItems = [];\n    var hiddenItems = [];\n    var item;\n    var i;\n\n    // If there are no items call the callback, but don't emit any events.\n    if (!counter) {\n      if (isFunction(callback)) callback(targetItems);\n      return;\n    }\n\n    // Emit showStart/hideStart event.\n    if (this._hasListeners(startEvent)) {\n      this._emit(startEvent, targetItems.slice(0));\n    }\n\n    // Show/hide items.\n    for (i = 0; i < targetItems.length; i++) {\n      item = targetItems[i];\n\n      // If inactive item is shown or active item is hidden we need to do\n      // layout.\n      if ((toVisible && !item._isActive) || (!toVisible && item._isActive)) {\n        needsLayout = true;\n      }\n\n      // If inactive item is shown we also need to do a little hack to make the\n      // item not animate it's next positioning (layout).\n      if (toVisible && !item._isActive) {\n        item._layout._skipNextAnimation = true;\n      }\n\n      // If a hidden item is being shown we need to refresh the item's\n      // dimensions.\n      if (toVisible && item._visibility._isHidden) {\n        hiddenItems.push(item);\n      }\n\n      // Show/hide the item.\n      item._visibility[method](isInstant, function(interrupted, item) {\n        // If the current item's animation was not interrupted add it to the\n        // completedItems array.\n        if (!interrupted) completedItems.push(item);\n\n        // If all items have finished their animations call the callback\n        // and emit showEnd/hideEnd event.\n        if (--counter < 1) {\n          if (isFunction(callback)) callback(completedItems.slice(0));\n          if (grid._hasListeners(endEvent)) grid._emit(endEvent, completedItems.slice(0));\n        }\n      });\n    }\n\n    // Refresh hidden items.\n    if (hiddenItems.length) this.refreshItems(hiddenItems);\n\n    // Layout if needed.\n    if (needsLayout && layout) {\n      this.layout(layout === instantLayout, isFunction(layout) ? layout : undefined);\n    }\n  };\n\n  /**\n   * Private helpers\n   * ***************\n   */\n\n  /**\n   * Merge default settings with user settings. The returned object is a new\n   * object with merged values. The merging is a deep merge meaning that all\n   * objects and arrays within the provided settings objects will be also merged\n   * so that modifying the values of the settings object will have no effect on\n   * the returned object.\n   *\n   * @param {Object} defaultSettings\n   * @param {Object} [userSettings]\n   * @returns {Object} Returns a new object.\n   */\n  function mergeSettings(defaultSettings, userSettings) {\n    // Create a fresh copy of default settings.\n    var ret = mergeObjects({}, defaultSettings);\n\n    // Merge user settings to default settings.\n    if (userSettings) {\n      ret = mergeObjects(ret, userSettings);\n    }\n\n    // Handle visible/hidden styles manually so that the whole object is\n    // overridden instead of the props.\n    ret.visibleStyles = (userSettings || 0).visibleStyles || (defaultSettings || 0).visibleStyles;\n    ret.hiddenStyles = (userSettings || 0).hiddenStyles || (defaultSettings || 0).hiddenStyles;\n\n    return ret;\n  }\n\n  /**\n   * Merge two objects recursively (deep merge). The source object's properties\n   * are merged to the target object.\n   *\n   * @param {Object} target\n   *   - The target object.\n   * @param {Object} source\n   *   - The source object.\n   * @returns {Object} Returns the target object.\n   */\n  function mergeObjects(target, source) {\n    var sourceKeys = Object.keys(source);\n    var length = sourceKeys.length;\n    var isSourceObject;\n    var propName;\n    var i;\n\n    for (i = 0; i < length; i++) {\n      propName = sourceKeys[i];\n      isSourceObject = isPlainObject(source[propName]);\n\n      // If target and source values are both objects, merge the objects and\n      // assign the merged value to the target property.\n      if (isPlainObject(target[propName]) && isSourceObject) {\n        target[propName] = mergeObjects(mergeObjects({}, target[propName]), source[propName]);\n        continue;\n      }\n\n      // If source's value is object and target's is not let's clone the object as\n      // the target's value.\n      if (isSourceObject) {\n        target[propName] = mergeObjects({}, source[propName]);\n        continue;\n      }\n\n      // If source's value is an array let's clone the array as the target's\n      // value.\n      if (Array.isArray(source[propName])) {\n        target[propName] = source[propName].slice(0);\n        continue;\n      }\n\n      // In all other cases let's just directly assign the source's value as the\n      // target's value.\n      target[propName] = source[propName];\n    }\n\n    return target;\n  }\n\n  return Grid;\n\n}));\n","import Store from './store'\r\nimport TodoList from './todoList'\r\nimport View from './View'\r\nimport { select, sanitize } from '../utils/helpers'\r\nimport Muuri from 'muuri'\r\n\r\nconst store = new Store()\r\nconst todoList = new TodoList(store.todoList)\r\n\r\nconst grid = new Muuri('#grid', { \r\n  dragEnabled: true,\r\n  dragStartPredicate: {\r\n    handle: '.handle'\r\n  }\r\n})\r\n\r\nconst list = select('#grid')\r\nconst input = select('#add-item')\r\n\r\nconst view = new View(grid, list, input)\r\n\r\nexport default class Controller {\r\n  constructor() {\r\n    this.handleDeleteButtonClick = this.handleDeleteButtonClick.bind(this)\r\n  }\r\n\r\n  provideItemHandlers() {\r\n    return {\r\n      handleToggleClick: this.handleToggleClick,\r\n      handleTodoContentDoubleClick: this.handleTodoContentDoubleClick,\r\n      handleDeleteButtonClick: this.handleDeleteButtonClick,\r\n      handleEditInputBlur: this.handleEditInputBlur,\r\n      handleEditInputKeyup: this.handleEditInputKeyup\r\n    }\r\n  }\r\n\r\n  initTodoList() {\r\n    const handlers = this.provideItemHandlers()\r\n\r\n    todoList.todos.forEach(todo => {\r\n      view.addItemToGrid(todo, handlers)\r\n    })\r\n\r\n    view.updateItemIndices()\r\n  }\r\n\r\n  handleInputKeydown(e) {\r\n    if (e.key === 'Enter') {\r\n      const name = e.target.value.trim()\r\n      const sanitizedName = sanitize(name)\r\n      \r\n      if (sanitizedName !== '') {\r\n        const todo = todoList.addItem(sanitizedName, false)\r\n        \r\n        store.todoList = todoList.todos\r\n\r\n        e.target.value = ''\r\n\r\n        const handlers = this.provideItemHandlers()\r\n\r\n        view.addItemToGrid(todo, handlers)\r\n        view.updateItemIndices()\r\n      }\r\n    }\r\n  }\r\n\r\n  handleGridDragReleaseEnd(item) {\r\n    const indices = []\r\n\r\n    const grid = item.getGrid()\r\n    const items = grid.getItems()\r\n\r\n    items.forEach(item => indices.push(item.getElement().dataset.index))\r\n\r\n    todoList.reorderItems(indices)\r\n\r\n    store.todoList = todoList.todos\r\n\r\n    view.updateItemIndices()\r\n  }\r\n\r\n  handleToggleClick(e) {\r\n    const listItem = e.target.closest('.item')\r\n    const id = parseInt(listItem.dataset.id)\r\n\r\n    const isCompleted = todoList.toggleItemStatus(id)\r\n\r\n    store.todoList = todoList.todos\r\n    \r\n    view.updateItemStyling(listItem, isCompleted)\r\n  }\r\n\r\n  handleTodoContentDoubleClick(e) {\r\n    const listItem = e.target.closest('.item')\r\n    const id = listItem.dataset.id\r\n    const editInput = select('.edit', listItem)\r\n\r\n    editInput.classList.remove('hidden')\r\n    editInput.value = select(`.todo-content[data-id=\"${id}\"]`).innerHTML\r\n    editInput.focus()\r\n  }\r\n\r\n  handleDeleteButtonClick(e) {\r\n    const id = parseInt(e.target.closest('.item').dataset.id)\r\n\r\n    todoList.removeItem(id)\r\n\r\n    store.todoList = todoList.todos\r\n\r\n    const handlers = this.provideItemHandlers()\r\n\r\n    view.removeItemFromGrid(id, handlers)\r\n    view.updateItemIndices()\r\n  }\r\n\r\n  handleEditInputBlur(e) {\r\n    e.target.classList.add('hidden')\r\n  }\r\n\r\n  handleEditInputKeyup(e) {\r\n    if (e.key === 'Enter') {\r\n      const id = parseInt(e.target.dataset.id)\r\n      const newName = e.target.value.trim()\r\n      const sanitizedNewName = sanitize(newName)\r\n\r\n      if (newName !== '') {\r\n        todoList.updateItemName(id, sanitizedNewName)\r\n\r\n        store.todoList = todoList.todos\r\n\r\n        view.updateItemName(id, sanitizedNewName)\r\n\r\n        e.target.blur()\r\n      }\r\n    }\r\n\r\n    if (e.key === 'Escape') {\r\n      e.target.blur()\r\n    }\r\n  }\r\n\r\n  setUpEventListeners() {\r\n    view.input.addEventListener('keydown', (e) => this.handleInputKeydown(e))\r\n    view.grid.on('dragReleaseEnd', this.handleGridDragReleaseEnd)\r\n  }\r\n}","import Controller from './classes/controller'\r\n\r\nwindow.addEventListener('DOMContentLoaded', () => {\r\n  const controller = new Controller()\r\n\r\n  controller.initTodoList()\r\n  controller.setUpEventListeners()\r\n})\r\n"]}